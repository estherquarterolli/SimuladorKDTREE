<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Simulador 2D - Auto Inser√ß√£o</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            text-decoration: none; color: #555; font-weight: bold;
            background: #ddd; padding: 8px 15px; border-radius: 5px;
            transition: 0.2s;
        }
        .back-btn:hover { background: #ccc; }

        h1 { margin-bottom: 10px; margin-top: 0; }
        p.subtitle { color: #666; font-size: 0.9em; margin-bottom: 20px; max-width: 600px; text-align: center;}

        /* --- LAYOUT --- */
        .main-container {
            display: flex; gap: 25px; justify-content: center;
            align-items: flex-start; flex-wrap: wrap; margin-bottom: 15px;
        }
        .panel {
            background: white; padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); text-align: center;
        }
        canvas { border: 1px solid #e1e4e8; background: #fafafa; cursor: crosshair; border-radius: 4px; }
        h3 { margin: 0 0 10px 0; color: #555; font-size: 1em; text-transform: uppercase; letter-spacing: 1px;}

        /* --- CONTROLES --- */
        .controls-area {
            background: white; padding: 20px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; gap: 15px; align-items: center;
            width: 100%; max-width: 830px;
        }
        
        .input-group { display: flex; gap: 10px; align-items: center; }
        input { 
            padding: 10px; width: 60px; text-align: center; 
            border: 1px solid #ddd; border-radius: 6px; outline: none; 
        }
        input:focus { border-color: #007bff; }
        label { font-size: 0.85em; font-weight: bold; color: #555; }

        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button {
            padding: 10px 15px; cursor: pointer; border: none; border-radius: 6px;
            color: white; font-weight: 600; font-size: 0.9em; transition: transform 0.1s;
        }
        button:active { transform: scale(0.96); }

        /* Cores dos Bot√µes */
        .btn-auto   { background: #16a085; min-width: 120px; } /* Verde √Ågua (Destaque) */
        .btn-insert { background: #27ae60; } 
        .btn-exact  { background: #2980b9; } 
        .btn-range  { background: #8e44ad; } 
        .btn-nn     { background: #e67e22; } 
        .btn-del    { background: #c0392b; } 
        .btn-clear  { background: #7f8c8d; } 

        /* --- CAIXINHA DE LOG PROFISSIONAL --- */
        #log-container {
            width: 100%; max-width: 830px; margin-top: 15px;
            background: #1e1e1e; border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85em; overflow: hidden; display: flex; flex-direction: column;
        }
        .log-header {
            background: #333; color: #ddd; padding: 5px 10px;
            font-size: 0.8em; border-bottom: 1px solid #444;
            display: flex; justify-content: space-between;
        }
        #log-content {
            height: 120px; overflow-y: auto; padding: 10px;
            list-style: none; margin: 0;
        }
        /* Estilos das linhas do log */
        .log-line { margin-bottom: 4px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-time { color: #666; margin-right: 8px; font-size: 0.9em; }
        
        .log-info { color: #aaa; }
        .log-success { color: #2ecc71; } 
        .log-error { color: #e74c3c; }   
        .log-highlight { color: #f1c40f; font-weight: bold; } 

        #log-content::-webkit-scrollbar { width: 8px; }
        #log-content::-webkit-scrollbar-track { background: #1e1e1e; }
        #log-content::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    </style>
</head>
<body>

    <a href="index.html" class="back-btn">‚¨Ö Voltar</a>

    <h1>Simulador K-D Tree (2D)</h1>
    <p class="subtitle">Inser√ß√£o Autom√°tica, Busca Exata, Busca por Intervalo e Vizinho Mais Pr√≥ximo</p>

    <div class="main-container">
        <div class="panel">
            <h3>Vis√£o Espacial (Mapa)</h3>
            <canvas id="spatialCanvas" width="400" height="400"></canvas>
        </div>
        <div class="panel">
            <h3>Vis√£o Hier√°rquica (√Årvore)</h3>
            <canvas id="treeCanvas" width="400" height="400"></canvas>
        </div>
    </div>

    <div class="controls-area">
        <div class="input-group">
            <div>
                <label>X:</label> <input type="number" id="inX" placeholder="0-400">
            </div>
            <div>
                <label>Y:</label> <input type="number" id="inY" placeholder="0-400">
            </div>
            <div style="border-left: 1px solid #ddd; padding-left: 10px; margin-left: 10px;">
                <label title="Usado para o tamanho do quadrado na Busca por Intervalo">Raio/Tam:</label> 
                <input type="number" id="inSize" value="50" placeholder="50">
            </div>
        </div>

        <div class="btn-group">
            <button id="btn-auto" class="btn-auto" onclick="toggleAutoInsert()">‚ñ∂ Auto Inserir</button>
            
            <button class="btn-insert" onclick="actionInsert()">+ Inserir 1</button>
            <button class="btn-exact" onclick="actionExactSearch()">üîç Busca Exata</button>
            <button class="btn-range" onclick="actionRangeSearch()">üì¶ Busca Intervalo</button>
            <button class="btn-nn" onclick="actionNearestNeighbor()">üéØ Vizinho + Pr√≥ximo</button>
            <button class="btn-del" onclick="actionDelete()">üóëÔ∏è Remover</button>
            <button class="btn-clear" onclick="resetAll()">‚ôªÔ∏è Limpar</button>
        </div>
    </div>

    <div id="log-container">
        <div class="log-header">
            <span>TERMINAL DE EXECU√á√ÉO</span>
            <span id="status-indicator" style="color:#aaa; font-size:0.9em;">Ocioso</span>
        </div>
        <ul id="log-content">
            <li class="log-line"><span class="log-time">00:00:00</span> <span class="log-info">Sistema iniciado.</span></li>
        </ul>
    </div>

    <script>
        // --- VARI√ÅVEIS E SETUP ---
        const spatialCv = document.getElementById('spatialCanvas');
        const spatialCtx = spatialCv.getContext('2d');
        const treeCv = document.getElementById('treeCanvas');
        const treeCtx = treeCv.getContext('2d');
        const logList = document.getElementById('log-content');
        
        let root = null;
        let autoInterval = null; // Para controlar a anima√ß√£o

        // --- CLASSE NODE ---
        class Node {
            constructor(point, axis) {
                this.point = point; // [x, y]
                this.left = null;
                this.right = null;
                this.axis = axis; // 0=X, 1=Y
            }
        }

        // --- ALGORITMOS KD-TREE ---
        function insert(node, point, depth) {
            if (!node) return new Node(point, depth % 2);
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node; 

            const axis = node.axis;
            if (point[axis] < node.point[axis]) {
                node.left = insert(node.left, point, depth + 1);
            } else {
                node.right = insert(node.right, point, depth + 1);
            }
            return node;
        }

        function findExact(node, point) {
            if (!node) return null;
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node;
            const axis = node.axis;
            if (point[axis] < node.point[axis]) return findExact(node.left, point);
            return findExact(node.right, point);
        }

        function rangeSearch(node, range, results = []) {
            if (!node) return results;
            const x = node.point[0]; const y = node.point[1];

            if (x >= range.minX && x <= range.maxX && y >= range.minY && y <= range.maxY) results.push(node);
            const axis = node.axis;
            if (axis === 0) {
                if (range.minX <= x) rangeSearch(node.left, range, results);
                if (range.maxX >= x) rangeSearch(node.right, range, results);
            } else {
                if (range.minY <= y) rangeSearch(node.left, range, results);
                if (range.maxY >= y) rangeSearch(node.right, range, results);
            }
            return results;
        }

        function nearestNeighbor(node, target, best = { node: null, dist: Infinity }) {
            if (!node) return best;
            const d = distSq(node.point, target);
            if (d < best.dist) { best.node = node; best.dist = d; }

            const axis = node.axis;
            const diff = target[axis] - node.point[axis];
            let goodSide = node.left; let badSide = node.right;
            if (diff > 0) { goodSide = node.right; badSide = node.left; }

            best = nearestNeighbor(goodSide, target, best);
            if (diff * diff < best.dist) best = nearestNeighbor(badSide, target, best);
            return best;
        }
        function distSq(p1, p2) { return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2; }

        function getAllPoints(node, list = []) {
            if (!node) return list;
            list.push(node.point);
            getAllPoints(node.left, list);
            getAllPoints(node.right, list);
            return list;
        }

        // --- VISUALIZA√á√ÉO ---
        function drawSpatial(highlightNodes = [], searchRect = null, nnData = null) {
            spatialCtx.clearRect(0, 0, spatialCv.width, spatialCv.height);
            if (root) drawSpatialNode(root, 0, spatialCv.width, 0, spatialCv.height, 0);

            if (searchRect) {
                spatialCtx.fillStyle = "rgba(142, 68, 173, 0.2)"; spatialCtx.strokeStyle = "#8e44ad"; spatialCtx.lineWidth = 2;
                const w = searchRect.maxX - searchRect.minX; const h = searchRect.maxY - searchRect.minY;
                spatialCtx.fillRect(searchRect.minX, searchRect.minY, w, h); spatialCtx.strokeRect(searchRect.minX, searchRect.minY, w, h);
            }
            highlightNodes.forEach(node => {
                spatialCtx.fillStyle = "#f1c40f"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 8, 0, Math.PI*2); spatialCtx.fill(); spatialCtx.strokeStyle = "black"; spatialCtx.stroke();
            });
            if (nnData) {
                spatialCtx.strokeStyle = "#e67e22"; spatialCtx.setLineDash([5, 5]);
                spatialCtx.beginPath(); spatialCtx.arc(nnData.target[0], nnData.target[1], Math.sqrt(nnData.dist), 0, Math.PI*2); spatialCtx.stroke(); spatialCtx.setLineDash([]);
                if (nnData.node) {
                    spatialCtx.beginPath(); spatialCtx.moveTo(nnData.target[0], nnData.target[1]); spatialCtx.lineTo(nnData.node.point[0], nnData.node.point[1]); spatialCtx.stroke();
                    spatialCtx.fillStyle = "#e67e22"; spatialCtx.beginPath(); spatialCtx.arc(nnData.node.point[0], nnData.node.point[1], 8, 0, Math.PI*2); spatialCtx.fill();
                }
            }
        }

        function drawSpatialNode(node, minX, maxX, minY, maxY, depth) {
            if (!node) return;
            spatialCtx.lineWidth = 1;
            if (node.axis === 0) { 
                spatialCtx.strokeStyle = "#ff6b6b";
                spatialCtx.beginPath(); spatialCtx.moveTo(node.point[0], minY); spatialCtx.lineTo(node.point[0], maxY); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, node.point[0], minY, maxY, depth + 1); drawSpatialNode(node.right, node.point[0], maxX, minY, maxY, depth + 1);
            } else { 
                spatialCtx.strokeStyle = "#4d96ff";
                spatialCtx.beginPath(); spatialCtx.moveTo(minX, node.point[1]); spatialCtx.lineTo(maxX, node.point[1]); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, maxX, minY, node.point[1], depth + 1); drawSpatialNode(node.right, minX, maxX, node.point[1], maxY, depth + 1);
            }
            spatialCtx.fillStyle = "#2d3436"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 4, 0, Math.PI*2); spatialCtx.fill();
            
            spatialCtx.fillStyle = "#636e72"; spatialCtx.font = "11px Arial";
            const label = `(${node.point[0]},${node.point[1]})`;
            let textX, textY;
            if (depth % 2 === 0) { spatialCtx.textAlign = "left"; spatialCtx.textBaseline = "bottom"; textX = node.point[0] + 6; textY = node.point[1] - 6; } 
            else { spatialCtx.textAlign = "right"; spatialCtx.textBaseline = "top"; textX = node.point[0] - 6; textY = node.point[1] + 6; }
            spatialCtx.fillText(label, textX, textY);
        }

        function drawHierarchy() {
            treeCtx.clearRect(0, 0, treeCv.width, treeCv.height);
            if (root) drawHierarchyNode(root, treeCv.width / 2, 30, treeCv.width / 4);
        }

        function drawHierarchyNode(node, x, y, offset) {
            if (!node) return;
            treeCtx.strokeStyle = "#b2bec3"; treeCtx.lineWidth = 2;
            if (node.left) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x - offset, y + 50); treeCtx.stroke(); drawHierarchyNode(node.left, x - offset, y + 50, offset / 2); }
            if (node.right) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x + offset, y + 50); treeCtx.stroke(); drawHierarchyNode(node.right, x + offset, y + 50, offset / 2); }
            treeCtx.fillStyle = node.axis === 0 ? "#fab1a0" : "#74b9ff"; treeCtx.strokeStyle = node.axis === 0 ? "#d63031" : "#0984e3"; treeCtx.lineWidth = 1;
            treeCtx.beginPath(); treeCtx.arc(x, y, 15, 0, Math.PI * 2); treeCtx.fill(); treeCtx.stroke();
            treeCtx.fillStyle = "#2d3436"; treeCtx.font = "bold 9px Arial"; treeCtx.textAlign = "center"; treeCtx.textBaseline = "middle"; treeCtx.fillText(`${node.point[0]},${node.point[1]}`, x, y);
        }

        // --- A√á√ïES E LOGS ---
        function log(msg, type = 'info') {
            const now = new Date(); const timeStr = now.toLocaleTimeString();
            const li = document.createElement('li'); li.className = `log-line log-${type}`;
            li.innerHTML = `<span class="log-time">${timeStr}</span> ${msg}`;
            logList.appendChild(li); logList.scrollTop = logList.scrollHeight;
        }

        function getInputs() {
            const x = parseInt(document.getElementById('inX').value);
            const y = parseInt(document.getElementById('inY').value);
            const size = parseInt(document.getElementById('inSize').value) || 50;
            return { x, y, size };
        }
        function updateAll() { drawSpatial(); drawHierarchy(); }

        // --- NOVA FUN√á√ÉO: AUTO INSER√á√ÉO ---
        function toggleAutoInsert() {
            const btn = document.getElementById('btn-auto');
            const status = document.getElementById('status-indicator');
            
            if (autoInterval) {
                // Parar
                clearInterval(autoInterval);
                autoInterval = null;
                btn.innerHTML = "‚ñ∂ Auto Inserir";
                btn.style.background = "#16a085"; // Volta ao verde
                status.innerText = "Pausado";
                log("Auto inser√ß√£o pausada.", "info");
            } else {
                // Iniciar
                log("Iniciando inser√ß√£o autom√°tica...", "info");
                btn.innerHTML = "‚è∏ Parar";
                btn.style.background = "#c0392b"; // Vermelho
                status.innerText = "Rodando...";
                status.style.color = "#2ecc71";
                
                // Limpa inputs para garantir que actionInsert gere aleat√≥rios
                document.getElementById('inX').value = '';
                document.getElementById('inY').value = '';

                // Executa imediatamente e depois no intervalo
                actionInsert(); 
                autoInterval = setInterval(() => {
                    // Limpa inputs novamente a cada ciclo por seguran√ßa
                    document.getElementById('inX').value = '';
                    document.getElementById('inY').value = '';
                    actionInsert();
                }, 300); // 300ms entre inser√ß√µes
            }
        }

        function actionInsert() {
            let { x, y } = getInputs();
            // Se estiver vazio ou rodando autom√°tico (inputs vazios), gera aleat√≥rio
            if (isNaN(x) || isNaN(y)) {
                x = Math.floor(Math.random()*380)+10;
                y = Math.floor(Math.random()*380)+10;
                // S√≥ preenche o input se N√ÉO estiver no modo autom√°tico (para n√£o piscar demais)
                if (!autoInterval) {
                    document.getElementById('inX').value = x;
                    document.getElementById('inY').value = y;
                }
            }
            root = insert(root, [x, y], 0);
            updateAll();
            log(`Inserido: (${x}, ${y})`, 'success');
        }

        function actionExactSearch() {
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");
            if (autoInterval) toggleAutoInsert(); // Pausa se tentar buscar
            
            const result = findExact(root, [x, y]);
            if (result) { log(`Encontrado: (${x}, ${y})`, 'success'); drawSpatial([result]); } 
            else { log(`N√£o existe: (${x}, ${y})`, 'error'); drawSpatial(); }
            drawHierarchy();
        }

        function actionRangeSearch() {
            const { x, y, size } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");
            if (autoInterval) toggleAutoInsert();

            const half = size / 2;
            const range = { minX: x - half, maxX: x + half, minY: y - half, maxY: y + half };
            log(`Busca Intervalo: Centro(${x},${y}) Raio ${half}`, 'info');
            const results = rangeSearch(root, range);
            if (results.length > 0) { log(`${results.length} pontos na regi√£o.`, 'highlight'); drawSpatial(results, range); } 
            else { log(`Nenhum ponto na regi√£o.`, 'info'); drawSpatial([], range); }
            drawHierarchy();
        }

        function actionNearestNeighbor() {
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");
            if (!root) return log("√Årvore vazia.", "error");
            if (autoInterval) toggleAutoInsert();

            const target = [x, y];
            const result = nearestNeighbor(root, target);
            if (result.node) {
                const dist = Math.sqrt(result.dist).toFixed(2);
                log(`Vizinho mais pr√≥ximo: (${result.node.point[0]}, ${result.node.point[1]}) Dist: ${dist}`, 'highlight');
                drawSpatial([], null, { target: target, node: result.node, dist: result.dist });
            }
            drawHierarchy();
        }

        function actionDelete() {
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");
            if (autoInterval) toggleAutoInsert();

            let points = getAllPoints(root);
            const initLen = points.length;
            points = points.filter(p => p[0] !== x || p[1] !== y);

            if (points.length === initLen) { log(`Erro: Ponto n√£o encontrado.`, 'error'); } 
            else {
                root = null; points.forEach(p => root = insert(root, p, 0));
                updateAll(); log(`Removido: (${x}, ${y})`, 'success');
            }
        }

        function resetAll() {
            // Se estiver rodando auto, para primeiro
            if (autoInterval) toggleAutoInsert();
            
            root = null;
            updateAll();
            log("√Årvore Resetada.", 'info');
            document.getElementById('inX').value = '';
            document.getElementById('inY').value = '';
        }

        spatialCv.addEventListener('mousedown', e => {
            const r = spatialCv.getBoundingClientRect();
            const x = Math.round(e.clientX - r.left);
            const y = Math.round(e.clientY - r.top);
            document.getElementById('inX').value = x;
            document.getElementById('inY').value = y;
            if(!autoInterval) log(`Selecionado: (${x}, ${y})`, 'info');
        });

    </script>
</body>
</html>
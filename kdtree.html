<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Simulador K-D Tree (Dashboard Corrigido)</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #eef1f5;
            margin: 0; padding: 20px;
            display: flex; flex-direction: column; height: 100vh;
            box-sizing: border-box; color: #333;
        }
        
        .back-btn {
            text-decoration: none; color: #555; font-weight: bold;
            display: flex; align-items: center; gap: 5px;
            font-size: 0.9rem; margin-bottom: 10px; width: fit-content;
        }
        .back-btn:hover { color: #000; text-decoration: underline; }

        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        h1 { margin: 0; font-size: 1.4rem; color: #2c3e50; }
        p.subtitle { margin: 0; color: #7f8c8d; font-size: 0.85rem; }

        /* --- LAYOUT DASHBOARD --- */
        .app-container {
            display: flex; flex: 1; gap: 20px; overflow: hidden;
        }

        /* ESQUERDA: VISUAL + CONTROLES */
        .left-pane {
            flex: 2; display: flex; flex-direction: column; gap: 10px;
            overflow-y: auto; padding-right: 5px;
        }

        .canvas-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }

        .panel {
            background: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05); text-align: center;
            flex: 1; min-width: 300px;
        }
        
        canvas { 
            border: 1px solid #eee; background: #fafafa; 
            cursor: crosshair; border-radius: 4px; width: 100%; max-width: 380px;
        }
        h3 { margin: 0 0 5px 0; color: #555; font-size: 0.8rem; text-transform: uppercase; font-weight: 600;}

        .controls-area {
            background: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; gap: 8px; align-items: center;
        }

        /* DIREITA: TERMINAL */
        .right-pane {
            flex: 1; display: flex; flex-direction: column; min-width: 320px;
        }

        #log-container {
            background: #1e1e1e; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; flex: 1;
            overflow: hidden; border: 1px solid #333;
        }
        .log-header {
            background: #252526; color: #ccc; padding: 8px 15px;
            font-size: 0.75rem; border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: bold; letter-spacing: 0.5px;
        }
        #log-content {
            flex: 1; overflow-y: auto; padding: 10px;
            list-style: none; margin: 0;
            font-family: 'Consolas', 'Fira Code', monospace; font-size: 0.8rem;
        }

        /* Linhas do Log */
        .log-line { margin-bottom: 4px; padding-left: 5px; line-height: 1.4; border-left: 2px solid transparent; }
        .log-time { color: #569cd6; margin-right: 8px; font-size: 0.7rem; opacity: 0.7; }
        
        .log-info { color: #d4d4d4; }
        .log-success { color: #4ec9b0; border-left-color: #4ec9b0; }
        .log-error { color: #f44747; border-left-color: #f44747; }
        .log-highlight { color: #dcdcaa; font-weight: bold; border-left-color: #dcdcaa; }
        
        /* Estilo do Passo a Passo */
        .log-step { color: #808080; font-size: 0.8rem; padding-left: 15px; display: block; }
        .log-step::before { content: "‚Ü≥ "; margin-right: 5px; color: #555; }
        
        .log-step-main { color: #9cdcfe; font-weight: bold; margin-top: 5px; display: block;} /* T√≠tulos de passos */

        /* Inputs e Bot√µes */
        .input-group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;}
        input { padding: 6px; width: 50px; text-align: center; border: 1px solid #ddd; border-radius: 4px; outline: none; }
        input:focus { border-color: #007bff; }
        label { font-size: 0.8rem; font-weight: bold; color: #555; }
        
        .btn-group { display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
        button {
            padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px;
            color: white; font-weight: 600; font-size: 0.8rem; transition: 0.1s;
        }
        button:hover { filter: brightness(110%); transform: translateY(-1px); }
        
        .btn-auto   { background: #16a085; width: 100px; }
        .btn-insert { background: #27ae60; } 
        .btn-exact  { background: #2980b9; } 
        .btn-range  { background: #8e44ad; } 
        .btn-nn     { background: #e67e22; } 
        .btn-del    { background: #c0392b; } 
        .btn-clear  { background: #7f8c8d; } 

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    </style>
</head>
<body>

    <header>
        <div>
            <a href="index.html" class="back-btn">‚¨Ö Voltar ao Menu</a>
            <h1>Simulador K-D Tree (2D)</h1>
            <p class="subtitle">Inser√ß√£o Autom√°tica, Busca Exata e Remo√ß√£o Detalhada.</p>
        </div>
    </header>

    <div class="app-container">
        
        <div class="left-pane">
            <div class="canvas-row">
                <div class="panel">
                    <h3>Espa√ßo</h3>
                    <canvas id="spatialCanvas" width="400" height="400"></canvas>
                </div>
                <div class="panel">
                    <h3>Hierarquia</h3>
                    <canvas id="treeCanvas" width="400" height="400"></canvas>
                </div>
            </div>

            <div class="controls-area">
                <div class="input-group">
                    <label>X:</label> <input type="number" id="inX" placeholder="X">
                    <label>Y:</label> <input type="number" id="inY" placeholder="Y">
                    <div style="width:1px; height:20px; background:#ddd; margin:0 5px;"></div>
                    <label>Raio:</label> <input type="number" id="inSize" value="50" placeholder="50">
                </div>

                <div class="btn-group">
                    <button id="btn-auto" class="btn-auto" onclick="toggleAutoInsert()">‚ñ∂ Auto</button>
                    <button class="btn-insert" onclick="actionInsert()">+ Inserir</button>
                    <button class="btn-exact" onclick="actionExactSearch()">üîç Busca Exata</button>
                    <button class="btn-range" onclick="actionRangeSearch()">üì¶ Intervalo</button>
                    <button class="btn-nn" onclick="actionNearestNeighbor()">üéØ Vizinho</button>
                    <button class="btn-del" onclick="actionDelete()">üóëÔ∏è Remover</button>
                    <button class="btn-clear" onclick="resetAll()">‚ôªÔ∏è Limpar</button>
                </div>
            </div>
        </div>

        <div class="right-pane">
            <div id="log-container">
                <div class="log-header">
                    <span>TERMINAL</span>
                    <span id="status-indicator" style="color:#6a9955;">‚óè Pronto</span>
                </div>
                <ul id="log-content">
                    <li class="log-line"><span class="log-time">Sys</span> <span class="log-info">Sistema iniciado.</span></li>
                </ul>
            </div>
        </div>

    </div>

    <script>
        // --- VARI√ÅVEIS GLOBAIS ---
        const spatialCv = document.getElementById('spatialCanvas');
        const spatialCtx = spatialCv.getContext('2d');
        const treeCv = document.getElementById('treeCanvas');
        const treeCtx = treeCv.getContext('2d');
        const logList = document.getElementById('log-content');
        
        let root = null;
        let autoInterval = null;

        // --- CLASSE NODE ---
        class Node {
            constructor(point, axis) {
                this.point = point; 
                this.left = null; this.right = null;
                this.axis = axis; 
            }
        }

        // --- ALGORITMOS (CORE) ---

        function insert(node, point, depth, verbose = false) {
            if (!node) {
                if(verbose) log(`N√≠vel ${depth}: Criando n√≥ folha (${point[0]}, ${point[1]})`, 'step');
                return new Node(point, depth % 2);
            }
            
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node; // Duplicata

            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            const val = point[axis];
            const nodeVal = node.point[axis];
            
            if (val < nodeVal) {
                if(verbose) log(`N√≠vel ${depth} [${axisName}]: ${val} < ${nodeVal} ‚Üí Esquerda`, 'step');
                node.left = insert(node.left, point, depth + 1, verbose);
            } else {
                if(verbose) log(`N√≠vel ${depth} [${axisName}]: ${val} ‚â• ${nodeVal} ‚Üí Direita`, 'step');
                node.right = insert(node.right, point, depth + 1, verbose);
            }
            return node;
        }

        function findExact(node, point, depth = 0) {
            if (!node) {
                log(`N√≠vel ${depth}: N√≥ nulo atingido. Ponto inexistente.`, 'step');
                return null;
            }
            
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node;

            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            
            // Log de decis√£o
            const dir = point[axis] < node.point[axis] ? "Esquerda" : "Direita";
            log(`N√≠vel ${depth}: N√≥(${node.point}). Busca ${axisName}=${point[axis]}. Indo para ${dir}`, 'step');

            if (point[axis] < node.point[axis]) return findExact(node.left, point, depth + 1);
            else return findExact(node.right, point, depth + 1);
        }

        // (Mantido igual)
        function rangeSearch(node, range, results = []) {
            if (!node) return results;
            const x = node.point[0]; const y = node.point[1];
            if (x >= range.minX && x <= range.maxX && y >= range.minY && y <= range.maxY) results.push(node);
            const axis = node.axis;
            if (axis === 0) {
                if (range.minX <= x) rangeSearch(node.left, range, results);
                if (range.maxX >= x) rangeSearch(node.right, range, results);
            } else {
                if (range.minY <= y) rangeSearch(node.left, range, results);
                if (range.maxY >= y) rangeSearch(node.right, range, results);
            }
            return results;
        }

        // (Mantido igual)
        function nearestNeighbor(node, target, best, depth = 0) {
            if (!node) return best;
            const dist = distSq(node.point, target);
            if (dist < best.dist) { best.node = node; best.dist = dist; }
            const axis = node.axis;
            const diff = target[axis] - node.point[axis];
            let good = node.left, bad = node.right;
            if (diff > 0) { good = node.right; bad = node.left; }
            best = nearestNeighbor(good, target, best, depth + 1);
            if (diff * diff < best.dist) best = nearestNeighbor(bad, target, best, depth + 1);
            return best;
        }

        function distSq(p1, p2) { return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2; }
        
        function getAllPoints(node, list = []) {
            if (!node) return list;
            list.push(node.point);
            getAllPoints(node.left, list); getAllPoints(node.right, list);
            return list;
        }

        // --- FUN√á√ïES DE VISUALIZA√á√ÉO ---
        function drawSpatial(highlightNodes = [], searchRect = null, nnData = null) {
            spatialCtx.clearRect(0, 0, spatialCv.width, spatialCv.height);
            if (root) drawSpatialNode(root, 0, spatialCv.width, 0, spatialCv.height, 0);

            if (searchRect) {
                spatialCtx.fillStyle = "rgba(142, 68, 173, 0.15)"; spatialCtx.strokeStyle = "#8e44ad"; spatialCtx.lineWidth = 2;
                const w = searchRect.maxX - searchRect.minX; const h = searchRect.maxY - searchRect.minY;
                spatialCtx.fillRect(searchRect.minX, searchRect.minY, w, h); spatialCtx.strokeRect(searchRect.minX, searchRect.minY, w, h);
            }
            highlightNodes.forEach(node => {
                spatialCtx.fillStyle = "#f1c40f"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 6, 0, Math.PI*2); spatialCtx.fill(); spatialCtx.stroke();
            });
            if (nnData && nnData.node) {
                spatialCtx.strokeStyle = "#e67e22"; spatialCtx.setLineDash([4, 4]);
                spatialCtx.beginPath(); spatialCtx.arc(nnData.target[0], nnData.target[1], Math.sqrt(nnData.dist), 0, Math.PI*2); spatialCtx.stroke(); spatialCtx.setLineDash([]);
                spatialCtx.beginPath(); spatialCtx.moveTo(nnData.target[0], nnData.target[1]); spatialCtx.lineTo(nnData.node.point[0], nnData.node.point[1]); spatialCtx.stroke();
                spatialCtx.fillStyle = "#e67e22"; spatialCtx.beginPath(); spatialCtx.arc(nnData.node.point[0], nnData.node.point[1], 6, 0, Math.PI*2); spatialCtx.fill();
            }
        }

        function drawSpatialNode(node, minX, maxX, minY, maxY, depth) {
            if (!node) return;
            spatialCtx.lineWidth = 1;
            if (node.axis === 0) { 
                spatialCtx.strokeStyle = "#ff6b6b";
                spatialCtx.beginPath(); spatialCtx.moveTo(node.point[0], minY); spatialCtx.lineTo(node.point[0], maxY); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, node.point[0], minY, maxY, depth + 1); drawSpatialNode(node.right, node.point[0], maxX, minY, maxY, depth + 1);
            } else { 
                spatialCtx.strokeStyle = "#4d96ff";
                spatialCtx.beginPath(); spatialCtx.moveTo(minX, node.point[1]); spatialCtx.lineTo(maxX, node.point[1]); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, maxX, minY, node.point[1], depth + 1); drawSpatialNode(node.right, minX, maxX, node.point[1], maxY, depth + 1);
            }
            spatialCtx.fillStyle = "#333"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 3, 0, Math.PI*2); spatialCtx.fill();
            
            spatialCtx.fillStyle = "#666"; spatialCtx.font = "10px Arial";
            let tx = node.point[0], ty = node.point[1];
            if (depth % 2 === 0) { spatialCtx.textAlign = "left"; spatialCtx.textBaseline = "bottom"; tx+=4; ty-=4; } 
            else { spatialCtx.textAlign = "right"; spatialCtx.textBaseline = "top"; tx-=4; ty+=4; }
            spatialCtx.fillText(`(${node.point})`, tx, ty);
        }

        function drawHierarchy() {
            treeCtx.clearRect(0, 0, treeCv.width, treeCv.height);
            if (root) drawHierarchyNode(root, treeCv.width / 2, 30, treeCv.width / 4);
        }

        function drawHierarchyNode(node, x, y, offset) {
            if (!node) return;
            treeCtx.strokeStyle = "#ccc"; treeCtx.lineWidth = 1;
            if (node.left) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x - offset, y + 45); treeCtx.stroke(); drawHierarchyNode(node.left, x - offset, y + 45, offset / 2); }
            if (node.right) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x + offset, y + 45); treeCtx.stroke(); drawHierarchyNode(node.right, x + offset, y + 45, offset / 2); }
            treeCtx.fillStyle = node.axis === 0 ? "#ffecec" : "#ecf3ff"; treeCtx.strokeStyle = node.axis === 0 ? "#e74c3c" : "#3498db"; treeCtx.lineWidth = 1;
            treeCtx.beginPath(); treeCtx.arc(x, y, 12, 0, Math.PI * 2); treeCtx.fill(); treeCtx.stroke();
            treeCtx.fillStyle = "#333"; treeCtx.font = "9px Arial"; treeCtx.textAlign = "center"; treeCtx.textBaseline = "middle"; treeCtx.fillText(`${node.point}`, x, y);
        }

        // --- LOG SYSTEM ---
        function log(msg, type = 'info') {
            if (autoInterval && type === 'step') return;
            const now = new Date(); 
            const timeStr = now.toLocaleTimeString('pt-BR', { hour12: false });
            const li = document.createElement('li'); 
            li.className = `log-line log-${type}`;
            
            if(type === 'step') li.className += ' log-step';
            if(type === 'step-main') li.className += ' log-step-main';

            if(type.startsWith('step')) li.innerHTML = `${msg}`;
            else li.innerHTML = `<span class="log-time">${timeStr}</span> ${msg}`;
            
            logList.appendChild(li); 
            requestAnimationFrame(() => { logList.scrollTop = logList.scrollHeight; });
        }
        
        function clearLog() { logList.innerHTML = ''; }
        function getInputs() {
            const x = parseInt(document.getElementById('inX').value);
            const y = parseInt(document.getElementById('inY').value);
            const size = parseInt(document.getElementById('inSize').value) || 50;
            return { x, y, size };
        }
        function updateAll() { drawSpatial(); drawHierarchy(); }

        // --- ACTIONS ---

        // 1. AUTO INSER√á√ÉO CORRIGIDA
        function toggleAutoInsert() {
            const btn = document.getElementById('btn-auto');
            if (autoInterval) {
                clearInterval(autoInterval); autoInterval = null;
                btn.innerText = "‚ñ∂ Auto"; btn.style.background = "#16a085";
                log("Auto inser√ß√£o parada.", 'info');
            } else {
                log("Auto inser√ß√£o iniciada...", 'info');
                btn.innerText = "‚è∏ Parar"; btn.style.background = "#c0392b";
                
                // Fun√ß√£o interna que for√ßa gera√ß√£o aleat√≥ria
                const runAuto = () => {
                    const rx = Math.floor(Math.random()*360)+20;
                    const ry = Math.floor(Math.random()*360)+20;
                    // N√£o chama getInputs, passa direto
                    actionInsert(rx, ry); 
                };
                
                runAuto();
                autoInterval = setInterval(runAuto, 400);
            }
        }

        // Aceita par√¢metros opcionais para o modo auto
        function actionInsert(autoX, autoY) {
            let x, y;
            
            if (typeof autoX !== 'undefined') {
                // Modo Auto
                x = autoX; y = autoY;
            } else {
                // Modo Manual
                const inp = getInputs();
                x = inp.x; y = inp.y;
                if (isNaN(x) || isNaN(y)) {
                    // Se manual mas vazio, gera aleat√≥rio e preenche
                    x = Math.floor(Math.random()*360)+20; 
                    y = Math.floor(Math.random()*360)+20;
                    document.getElementById('inX').value = x;
                    document.getElementById('inY').value = y;
                }
                clearLog();
                log(`Inserindo Ponto (${x}, ${y})...`, 'step-main');
            }

            root = insert(root, [x, y], 0, !autoInterval); // Verbose s√≥ se n√£o for auto
            updateAll();
            if(!autoInterval) log(`Sucesso: (${x},${y}) adicionado.`, 'success');
        }

        // 2. BUSCA EXATA CORRIGIDA
        function actionExactSearch() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            
            // Corre√ß√£o: Verifica X E Y
            if (isNaN(x) || isNaN(y)) return log("Erro: Preencha X e Y.", 'error');
            
            log(`Iniciando Busca Exata por (${x}, ${y})...`, 'step-main');
            const res = findExact(root, [x,y]);
            
            if(res) { 
                log(`Resultado: ENCONTRADO!`, 'success'); 
                drawSpatial([res]); 
            } else { 
                log(`Resultado: Ponto n√£o existe na √°rvore.`, 'error'); 
                drawSpatial(); 
            }
        }

        // 3. REMO√á√ÉO COM LOG DETALHADO (PASSO A PASSO SIMULADO)
        function actionDelete() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Preencha X e Y.", 'error');

            log(`Iniciando Protocolo de Remo√ß√£o de (${x},${y})`, 'step-main');
            
            // Passo 1: Verificar exist√™ncia
            log(`Passo 1: Buscando n√≥ alvo na estrutura...`, 'step');
            let pts = getAllPoints(root);
            const exists = pts.find(p => p[0] === x && p[1] === y);
            
            if (!exists) {
                log(`Falha: Ponto n√£o encontrado. Opera√ß√£o abortada.`, 'error');
                return;
            }
            
            log(`Sucesso: Alvo localizado.`, 'step');

            // Passo 2: Isolamento
            log(`Passo 2: Isolando n√≥ e coletando n√≥s remanescentes...`, 'step');
            const remaining = pts.filter(p => p[0] !== x || p[1] !== y);
            
            // Passo 3: Reconstru√ß√£o
            log(`Passo 3: Removendo n√≥ e rebalanceando √°rvore...`, 'step');
            root = null; 
            
            // Reconstr√≥i silenciosamente para atualizar a view
            remaining.forEach(p => root = insert(root, p, 0, false));
            
            updateAll(); 
            log(`Opera√ß√£o conclu√≠da: (${x},${y}) removido. Estrutura √≠ntegra.`, 'success');
        }

        function actionRangeSearch() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y, size } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Centro X, Y necess√°rio.", 'error');
            log(`Busca por Intervalo (Raio ${size})`, 'step-main');
            const half = size/2;
            const range = { minX:x-half, maxX:x+half, minY:y-half, maxY:y+half };
            const res = rangeSearch(root, range);
            if(res.length) { log(`Encontrados ${res.length} pontos.`, 'highlight'); drawSpatial(res, range); }
            else { log(`Nenhum ponto na √°rea.`, 'info'); drawSpatial([], range); }
        }

        function actionNearestNeighbor() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Alvo X, Y necess√°rio.", 'error');
            if (!root) return log("√Årvore vazia.", 'error');
            log(`Calculando Vizinho Mais Pr√≥ximo de (${x},${y})`, 'step-main');
            const res = nearestNeighbor(root, [x,y], {node:null, dist:Infinity});
            if(res.node) {
                const d = Math.sqrt(res.dist).toFixed(1);
                log(`Vizinho: (${res.node.point}) | Dist√¢ncia: ${d}`, 'highlight');
                drawSpatial([], null, {target:[x,y], node:res.node, dist:res.dist});
            }
        }

        function resetAll() {
            if(autoInterval) toggleAutoInsert();
            root = null; updateAll(); clearLog(); log("Mem√≥ria limpa.", 'info');
        }

        spatialCv.addEventListener('mousedown', e => {
            const r = spatialCv.getBoundingClientRect();
            const x = Math.round(e.clientX - r.left);
            const y = Math.round(e.clientY - r.top);
            document.getElementById('inX').value = x;
            document.getElementById('inY').value = y;
            if(!autoInterval) {
                // Feedback visual r√°pido
                log(`Coordenada selecionada: (${x}, ${y})`, 'info');
            }
        });
    </script>
</body>
</html>
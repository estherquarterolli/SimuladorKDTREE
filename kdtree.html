<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Simulador K-D Tree (Dashboard)</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #eef1f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
            color: #333;
        }
        
        .back-btn {
            text-decoration: none; color: #555; font-weight: bold;
            display: flex; align-items: center; gap: 5px;
            font-size: 0.9rem; margin-bottom: 10px; width: fit-content;
        }
        .back-btn:hover { color: #000; text-decoration: underline; }

        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        h1 { margin: 0; font-size: 1.5rem; color: #2c3e50; }
        p.subtitle { margin: 0; color: #7f8c8d; font-size: 0.9rem; }

        /* --- LAYOUT DASHBOARD (PRINCIPAL MUDAN√áA) --- */
        .app-container {
            display: flex;
            flex: 1; /* Ocupa o resto da altura */
            gap: 20px;
            overflow: hidden; /* Impede scroll na p√°gina toda, usa scroll interno */
        }

        /* COLUNA ESQUERDA: VISUAL + CONTROLES */
        .left-pane {
            flex: 2; /* Ocupa 66% da largura */
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto; /* Scroll se a tela for pequena */
            padding-right: 5px;
        }

        .canvas-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .panel {
            background: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05); text-align: center;
            flex: 1; min-width: 300px;
        }
        
        canvas { 
            border: 1px solid #eee; background: #fafafa; 
            cursor: crosshair; border-radius: 4px; width: 100%; max-width: 400px; height: auto;
        }
        h3 { margin: 0 0 8px 0; color: #555; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;}

        .controls-area {
            background: white; padding: 15px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; gap: 10px; align-items: center;
        }

        /* COLUNA DIREITA: TERMINAL */
        .right-pane {
            flex: 1; /* Ocupa 33% da largura */
            display: flex;
            flex-direction: column;
            min-width: 300px;
        }

        /* --- CAIXINHA DE LOG (ESTILO VS CODE) --- */
        #log-container {
            background: #1e1e1e; 
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex; 
            flex-direction: column;
            flex: 1; /* Estica at√© o fim da tela */
            overflow: hidden;
            border: 1px solid #333;
        }
        .log-header {
            background: #252526; color: #ccc; padding: 8px 15px;
            font-size: 0.8rem; border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
            font-family: 'Segoe UI', sans-serif; font-weight: bold; letter-spacing: 0.5px;
        }
        #log-content {
            flex: 1; /* Ocupa todo espa√ßo restante */
            overflow-y: auto; padding: 10px;
            list-style: none; margin: 0;
            font-family: 'Consolas', 'Fira Code', monospace;
            font-size: 0.85rem;
        }

        /* Estilos das linhas do log */
        .log-line { margin-bottom: 6px; padding-left: 5px; line-height: 1.4; border-left: 2px solid transparent; }
        .log-line:hover { background: rgba(255,255,255,0.05); }
        
        .log-time { color: #569cd6; margin-right: 8px; font-size: 0.75rem; opacity: 0.7; }
        
        .log-info { color: #d4d4d4; }
        .log-success { color: #4ec9b0; border-left-color: #4ec9b0; } /* Verde ciano */
        .log-error { color: #f44747; border-left-color: #f44747; }   /* Vermelho */
        .log-highlight { color: #dcdcaa; font-weight: bold; border-left-color: #dcdcaa; } /* Amarelo suave */
        
        .log-step { color: #808080; font-size: 0.8rem; padding-left: 15px; }
        .log-step::before { content: "‚Ä∫"; margin-right: 5px; color: #555; }

        /* Scrollbar bonita */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        #log-content::-webkit-scrollbar-track { background: #1e1e1e; }
        #log-content::-webkit-scrollbar-thumb { background: #444; }

        /* Inputs e Bot√µes */
        .input-group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;}
        input { padding: 8px; width: 50px; text-align: center; border: 1px solid #ddd; border-radius: 4px; outline: none; }
        input:focus { border-color: #007bff; box-shadow: 0 0 0 2px rgba(0,123,255,0.1); }
        label { font-size: 0.8rem; font-weight: bold; color: #555; }
        
        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        button {
            padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px;
            color: white; font-weight: 600; font-size: 0.85rem; transition: 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover { filter: brightness(110%); transform: translateY(-1px); }
        button:active { transform: translateY(0); }

        /* Cores Bot√µes */
        .btn-auto   { background: #16a085; }
        .btn-insert { background: #27ae60; } 
        .btn-exact  { background: #2980b9; } 
        .btn-range  { background: #8e44ad; } 
        .btn-nn     { background: #e67e22; } 
        .btn-del    { background: #c0392b; } 
        .btn-clear  { background: #7f8c8d; } 
    </style>
</head>
<body>

    <header>
        <div>
            <a href="index.html" class="back-btn">‚¨Ö Voltar ao Menu</a>
            <h1>Simulador K-D Tree (2D)</h1>
            <p class="subtitle">Acompanhe a l√≥gica da √°rvore em tempo real no terminal.</p>
        </div>
    </header>

    <div class="app-container">
        
        <div class="left-pane">
            <div class="canvas-row">
                <div class="panel">
                    <h3>Vis√£o Espacial</h3>
                    <canvas id="spatialCanvas" width="400" height="400"></canvas>
                </div>
                <div class="panel">
                    <h3>Estrutura de Dados</h3>
                    <canvas id="treeCanvas" width="400" height="400"></canvas>
                </div>
            </div>

            <div class="controls-area">
                <div class="input-group">
                    <label>X:</label> <input type="number" id="inX" placeholder="X">
                    <label>Y:</label> <input type="number" id="inY" placeholder="Y">
                    <div style="width:1px; height:20px; background:#ddd; margin:0 10px;"></div>
                    <label>Raio:</label> <input type="number" id="inSize" value="50" placeholder="50">
                </div>

                <div class="btn-group">
                    <button id="btn-auto" class="btn-auto" onclick="toggleAutoInsert()">‚ñ∂ Auto</button>
                    <button class="btn-insert" onclick="actionInsert()">+ Inserir</button>
                    <button class="btn-exact" onclick="actionExactSearch()">üîç Busca Exata</button>
                    <button class="btn-range" onclick="actionRangeSearch()">üì¶ Intervalo</button>
                    <button class="btn-nn" onclick="actionNearestNeighbor()">üéØ Vizinho</button>
                    <button class="btn-del" onclick="actionDelete()">üóëÔ∏è Remover</button>
                    <button class="btn-clear" onclick="resetAll()">‚ôªÔ∏è Limpar</button>
                </div>
            </div>
        </div>

        <div class="right-pane">
            <div id="log-container">
                <div class="log-header">
                    <span>TERMINAL DE EXECU√á√ÉO</span>
                    <span id="status-indicator" style="color:#6a9955; font-size:0.7rem;">‚óè Online</span>
                </div>
                <ul id="log-content">
                    <li class="log-line"><span class="log-time">Sys</span> <span class="log-info">Ambiente inicializado.</span></li>
                    <li class="log-line"><span class="log-time">Hint</span> <span class="log-step">Use os bot√µes √† esquerda para operar.</span></li>
                </ul>
            </div>
        </div>

    </div>

    <script>
        // --- VARI√ÅVEIS ---
        const spatialCv = document.getElementById('spatialCanvas');
        const spatialCtx = spatialCv.getContext('2d');
        const treeCv = document.getElementById('treeCanvas');
        const treeCtx = treeCv.getContext('2d');
        const logList = document.getElementById('log-content');
        
        let root = null;
        let autoInterval = null;

        // --- CLASSE NODE ---
        class Node {
            constructor(point, axis) {
                this.point = point; 
                this.left = null; this.right = null;
                this.axis = axis; 
            }
        }

        // --- LOGIC HELPERS ---
        const getIndent = (depth) => " ".repeat(depth * 2);

        // --- ALGORITMOS CORE ---

        function insert(node, point, depth, verbose = false) {
            if (!node) {
                if(verbose) log(`${getIndent(depth)}Criou n√≥ folha.`, 'step');
                return new Node(point, depth % 2);
            }
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node;

            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            
            if (point[axis] < node.point[axis]) {
                if(verbose) log(`${getIndent(depth)}Comp ${axisName}: ${point[axis]} < ${node.point[axis]} ‚Üí Esq`, 'step');
                node.left = insert(node.left, point, depth + 1, verbose);
            } else {
                if(verbose) log(`${getIndent(depth)}Comp ${axisName}: ${point[axis]} ‚â• ${node.point[axis]} ‚Üí Dir`, 'step');
                node.right = insert(node.right, point, depth + 1, verbose);
            }
            return node;
        }

        function findExact(node, point, depth = 0) {
            if (!node) {
                log(`${getIndent(depth)}N√≥ nulo atingido.`, 'step');
                return null;
            }
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node;
            
            const axis = node.axis;
            const dir = point[axis] < node.point[axis] ? "Esq" : "Dir";
            log(`${getIndent(depth)}N√≥(${node.point}) eixo ${axis===0?'X':'Y'}. Indo para ${dir}`, 'step');

            if (point[axis] < node.point[axis]) return findExact(node.left, point, depth + 1);
            else return findExact(node.right, point, depth + 1);
        }

        function rangeSearch(node, range, results = [], depth = 0) {
            if (!node) return results;
            const x = node.point[0]; const y = node.point[1];
            
            // Check Inside
            if (x >= range.minX && x <= range.maxX && y >= range.minY && y <= range.maxY) {
                log(`${getIndent(depth)}‚òÖ Ponto (${x},${y}) capturado!`, 'step');
                results.push(node);
            }

            // Pruning Logic
            const axis = node.axis;
            if (axis === 0) { // X
                if (range.minX <= x) rangeSearch(node.left, range, results, depth+1);
                else log(`${getIndent(depth)}Poda Esquerda (Range MinX > Node X)`, 'step');

                if (range.maxX >= x) rangeSearch(node.right, range, results, depth+1);
                else log(`${getIndent(depth)}Poda Direita (Range MaxX < Node X)`, 'step');
            } else { // Y
                if (range.minY <= y) rangeSearch(node.left, range, results, depth+1);
                else log(`${getIndent(depth)}Poda Cima (Range MinY > Node Y)`, 'step');

                if (range.maxY >= y) rangeSearch(node.right, range, results, depth+1);
                else log(`${getIndent(depth)}Poda Baixo (Range MaxY < Node Y)`, 'step');
            }
            return results;
        }

        function nearestNeighbor(node, target, best, depth = 0) {
            if (!node) return best;
            const dist = distSq(node.point, target);
            
            if (dist < best.dist) {
                best.node = node; best.dist = dist;
                log(`${getIndent(depth)}Novo Melhor: (${node.point}) d=${Math.sqrt(dist).toFixed(1)}`, 'step');
            }

            const axis = node.axis;
            const diff = target[axis] - node.point[axis];
            let good = node.left, bad = node.right;
            if (diff > 0) { good = node.right; bad = node.left; }

            best = nearestNeighbor(good, target, best, depth + 1);

            if (diff * diff < best.dist) {
                log(`${getIndent(depth)}Backtracking: Cruzando plano...`, 'step');
                best = nearestNeighbor(bad, target, best, depth + 1);
            }
            return best;
        }

        function distSq(p1, p2) { return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2; }
        function getAllPoints(node, list = []) {
            if (!node) return list;
            list.push(node.point);
            getAllPoints(node.left, list); getAllPoints(node.right, list);
            return list;
        }

        // --- VISUALIZA√á√ÉO ---
        function drawSpatial(highlightNodes = [], searchRect = null, nnData = null) {
            spatialCtx.clearRect(0, 0, spatialCv.width, spatialCv.height);
            if (root) drawSpatialNode(root, 0, spatialCv.width, 0, spatialCv.height, 0);

            if (searchRect) {
                spatialCtx.fillStyle = "rgba(142, 68, 173, 0.15)"; spatialCtx.strokeStyle = "#8e44ad"; spatialCtx.lineWidth = 2;
                const w = searchRect.maxX - searchRect.minX; const h = searchRect.maxY - searchRect.minY;
                spatialCtx.fillRect(searchRect.minX, searchRect.minY, w, h); spatialCtx.strokeRect(searchRect.minX, searchRect.minY, w, h);
            }
            highlightNodes.forEach(node => {
                spatialCtx.fillStyle = "#f1c40f"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 6, 0, Math.PI*2); spatialCtx.fill(); spatialCtx.stroke();
            });
            if (nnData) {
                spatialCtx.strokeStyle = "#e67e22"; spatialCtx.setLineDash([4, 4]);
                spatialCtx.beginPath(); spatialCtx.arc(nnData.target[0], nnData.target[1], Math.sqrt(nnData.dist), 0, Math.PI*2); spatialCtx.stroke(); spatialCtx.setLineDash([]);
                if (nnData.node) {
                    spatialCtx.beginPath(); spatialCtx.moveTo(nnData.target[0], nnData.target[1]); spatialCtx.lineTo(nnData.node.point[0], nnData.node.point[1]); spatialCtx.stroke();
                    spatialCtx.fillStyle = "#e67e22"; spatialCtx.beginPath(); spatialCtx.arc(nnData.node.point[0], nnData.node.point[1], 6, 0, Math.PI*2); spatialCtx.fill();
                }
            }
        }

        function drawSpatialNode(node, minX, maxX, minY, maxY, depth) {
            if (!node) return;
            spatialCtx.lineWidth = 1;
            if (node.axis === 0) { 
                spatialCtx.strokeStyle = "#ff6b6b";
                spatialCtx.beginPath(); spatialCtx.moveTo(node.point[0], minY); spatialCtx.lineTo(node.point[0], maxY); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, node.point[0], minY, maxY, depth + 1); drawSpatialNode(node.right, node.point[0], maxX, minY, maxY, depth + 1);
            } else { 
                spatialCtx.strokeStyle = "#4d96ff";
                spatialCtx.beginPath(); spatialCtx.moveTo(minX, node.point[1]); spatialCtx.lineTo(maxX, node.point[1]); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, maxX, minY, node.point[1], depth + 1); drawSpatialNode(node.right, minX, maxX, node.point[1], maxY, depth + 1);
            }
            spatialCtx.fillStyle = "#333"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 3, 0, Math.PI*2); spatialCtx.fill();
            
            // Texto Inteligente
            spatialCtx.fillStyle = "#666"; spatialCtx.font = "10px Arial";
            let tx = node.point[0], ty = node.point[1];
            if (depth % 2 === 0) { spatialCtx.textAlign = "left"; spatialCtx.textBaseline = "bottom"; tx+=4; ty-=4; } 
            else { spatialCtx.textAlign = "right"; spatialCtx.textBaseline = "top"; tx-=4; ty+=4; }
            spatialCtx.fillText(`(${node.point})`, tx, ty);
        }

        function drawHierarchy() {
            treeCtx.clearRect(0, 0, treeCv.width, treeCv.height);
            if (root) drawHierarchyNode(root, treeCv.width / 2, 30, treeCv.width / 4);
        }

        function drawHierarchyNode(node, x, y, offset) {
            if (!node) return;
            treeCtx.strokeStyle = "#ccc"; treeCtx.lineWidth = 1;
            if (node.left) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x - offset, y + 45); treeCtx.stroke(); drawHierarchyNode(node.left, x - offset, y + 45, offset / 2); }
            if (node.right) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x + offset, y + 45); treeCtx.stroke(); drawHierarchyNode(node.right, x + offset, y + 45, offset / 2); }
            
            treeCtx.fillStyle = node.axis === 0 ? "#ffecec" : "#ecf3ff"; 
            treeCtx.strokeStyle = node.axis === 0 ? "#e74c3c" : "#3498db";
            treeCtx.lineWidth = 1;
            treeCtx.beginPath(); treeCtx.arc(x, y, 13, 0, Math.PI * 2); treeCtx.fill(); treeCtx.stroke();
            treeCtx.fillStyle = "#333"; treeCtx.font = "9px Arial"; treeCtx.textAlign = "center"; treeCtx.textBaseline = "middle";
            treeCtx.fillText(`${node.point}`, x, y);
        }

        // --- SISTEMA DE LOG ---
        function log(msg, type = 'info') {
            if (autoInterval && type === 'step') return; // Evita spam no auto
            const now = new Date(); 
            const timeStr = now.toLocaleTimeString('pt-BR', { hour12: false });
            const li = document.createElement('li'); 
            li.className = `log-line log-${type}`;
            
            if(type === 'step') li.innerHTML = `${msg}`;
            else li.innerHTML = `<span class="log-time">${timeStr}</span> ${msg}`;
            
            logList.appendChild(li); 
            // Auto Scroll Suave
            requestAnimationFrame(() => { logList.scrollTop = logList.scrollHeight; });
        }
        
        function clearLog() { logList.innerHTML = ''; }
        function getInputs() {
            const x = parseInt(document.getElementById('inX').value);
            const y = parseInt(document.getElementById('inY').value);
            const size = parseInt(document.getElementById('inSize').value) || 50;
            return { x, y, size };
        }
        function updateAll() { drawSpatial(); drawHierarchy(); }

        // --- A√á√ïES DO USU√ÅRIO ---

        function toggleAutoInsert() {
            const btn = document.getElementById('btn-auto');
            if (autoInterval) {
                clearInterval(autoInterval); autoInterval = null;
                btn.innerText = "‚ñ∂ Auto"; btn.style.background = "#16a085";
                log("Auto inser√ß√£o parada.", 'info');
            } else {
                log("Iniciando auto inser√ß√£o...", 'info');
                btn.innerText = "‚è∏ Parar"; btn.style.background = "#c0392b";
                actionInsert(); 
                autoInterval = setInterval(actionInsert, 400);
            }
        }

        function actionInsert() {
            let { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) {
                x = Math.floor(Math.random()*360)+20; y = Math.floor(Math.random()*360)+20;
                if (!autoInterval) { document.getElementById('inX').value = x; document.getElementById('inY').value = y; }
            }
            if(!autoInterval) { clearLog(); log(`Inserindo (${x},${y})...`, 'info'); }
            root = insert(root, [x, y], 0, true);
            updateAll();
            if(!autoInterval) log(`OK: (${x},${y}) inserido.`, 'success');
        }

        function actionExactSearch() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x)) return log("Erro: Defina X e Y.", 'error');
            log(`Buscando (${x},${y})...`, 'info');
            const res = findExact(root, [x,y]);
            if(res) { log(`ENCONTRADO!`, 'success'); drawSpatial([res]); }
            else { log(`N√£o encontrado.`, 'error'); drawSpatial(); }
        }

        function actionRangeSearch() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y, size } = getInputs();
            if (isNaN(x)) return log("Erro: Defina centro X, Y.", 'error');
            const half = size/2;
            const range = { minX:x-half, maxX:x+half, minY:y-half, maxY:y+half };
            log(`Range Search: Centro(${x},${y}) Tamanho ${size}`, 'info');
            const res = rangeSearch(root, range);
            if(res.length) { log(`FIM: ${res.length} pontos na √°rea.`, 'highlight'); drawSpatial(res, range); }
            else { log(`FIM: Nenhum ponto na √°rea.`, 'info'); drawSpatial([], range); }
        }

        function actionNearestNeighbor() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x)) return log("Erro: Defina alvo X, Y.", 'error');
            if (!root) return log("√Årvore vazia.", 'error');
            log(`Procurando Vizinho de (${x},${y})...`, 'info');
            const res = nearestNeighbor(root, [x,y], {node:null, dist:Infinity});
            if(res.node) {
                log(`MELHOR VIZINHO: (${res.node.point})`, 'highlight');
                drawSpatial([], null, {target:[x,y], node:res.node, dist:res.dist});
            }
        }

        function actionDelete() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x)) return log("Erro: X e Y necess√°rios.", 'error');
            let pts = getAllPoints(root);
            const pre = pts.length;
            pts = pts.filter(p => p[0]!==x || p[1]!==y);
            if(pts.length === pre) log("Ponto n√£o existe.", 'error');
            else {
                root = null; pts.forEach(p => root = insert(root, p, 0, false));
                updateAll(); log(`Ponto (${x},${y}) deletado.`, 'success');
            }
        }

        function resetAll() {
            if(autoInterval) toggleAutoInsert();
            root = null; updateAll(); clearLog(); log("Sistema resetado.", 'info');
        }

        spatialCv.addEventListener('mousedown', e => {
            const r = spatialCv.getBoundingClientRect();
            document.getElementById('inX').value = Math.round(e.clientX - r.left);
            document.getElementById('inY').value = Math.round(e.clientY - r.top);
        });
    </script>
</body>
</html>
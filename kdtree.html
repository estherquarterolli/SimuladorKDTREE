<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Simulador 2D - Logs Detalhados</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            text-decoration: none; color: #555; font-weight: bold;
            background: #ddd; padding: 8px 15px; border-radius: 5px;
            transition: 0.2s;
        }
        .back-btn:hover { background: #ccc; }

        h1 { margin-bottom: 10px; margin-top: 0; }
        p.subtitle { color: #666; font-size: 0.9em; margin-bottom: 20px; max-width: 600px; text-align: center;}

        /* --- LAYOUT --- */
        .main-container {
            display: flex; gap: 25px; justify-content: center;
            align-items: flex-start; flex-wrap: wrap; margin-bottom: 15px;
        }
        .panel {
            background: white; padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); text-align: center;
        }
        canvas { border: 1px solid #e1e4e8; background: #fafafa; cursor: crosshair; border-radius: 4px; }
        h3 { margin: 0 0 10px 0; color: #555; font-size: 1em; text-transform: uppercase; letter-spacing: 1px;}

        /* --- CONTROLES --- */
        .controls-area {
            background: white; padding: 20px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; gap: 15px; align-items: center;
            width: 100%; max-width: 830px;
        }
        
        .input-group { display: flex; gap: 10px; align-items: center; }
        input { 
            padding: 10px; width: 60px; text-align: center; 
            border: 1px solid #ddd; border-radius: 6px; outline: none; 
        }
        input:focus { border-color: #007bff; }
        label { font-size: 0.85em; font-weight: bold; color: #555; }

        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button {
            padding: 10px 15px; cursor: pointer; border: none; border-radius: 6px;
            color: white; font-weight: 600; font-size: 0.9em; transition: transform 0.1s;
        }
        button:active { transform: scale(0.96); }

        /* Cores dos Bot√µes */
        .btn-auto   { background: #16a085; min-width: 120px; }
        .btn-insert { background: #27ae60; } 
        .btn-exact  { background: #2980b9; } 
        .btn-range  { background: #8e44ad; } 
        .btn-nn     { background: #e67e22; } 
        .btn-del    { background: #c0392b; } 
        .btn-clear  { background: #7f8c8d; } 

        /* --- CAIXINHA DE LOG PROFISSIONAL --- */
        #log-container {
            width: 100%; max-width: 830px; margin-top: 15px;
            background: #1e1e1e; border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85em; overflow: hidden; display: flex; flex-direction: column;
        }
        .log-header {
            background: #333; color: #ddd; padding: 5px 10px;
            font-size: 0.8em; border-bottom: 1px solid #444;
            display: flex; justify-content: space-between;
        }
        #log-content {
            height: 150px; overflow-y: auto; padding: 10px; /* Altura aumentada para ver os passos */
            list-style: none; margin: 0;
        }
        
        /* Estilos das linhas do log */
        .log-line { margin-bottom: 4px; border-bottom: 1px solid #2a2a2a; padding-bottom: 2px; }
        .log-time { color: #555; margin-right: 8px; font-size: 0.8em; }
        
        .log-info { color: #aaa; }
        .log-success { color: #2ecc71; font-weight: bold; } 
        .log-error { color: #e74c3c; }   
        .log-highlight { color: #f1c40f; font-weight: bold; } 
        
        /* NOVO: Estilo para o passo a passo */
        .log-step { color: #6c757d; padding-left: 15px; font-size: 0.9em; border-left: 2px solid #444; margin-left: 5px; }
        .log-step em { color: #888; font-style: normal; }

        #log-content::-webkit-scrollbar { width: 8px; }
        #log-content::-webkit-scrollbar-track { background: #1e1e1e; }
        #log-content::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    </style>
</head>
<body>

    <a href="index.html" class="back-btn">‚¨Ö Voltar</a>

    <h1>Simulador K-D Tree (2D)</h1>
    <p class="subtitle">Logs detalhados mostrando o processo de decis√£o da √°rvore</p>

    <div class="main-container">
        <div class="panel">
            <h3>Vis√£o Espacial</h3>
            <canvas id="spatialCanvas" width="400" height="400"></canvas>
        </div>
        <div class="panel">
            <h3>Vis√£o Hier√°rquica</h3>
            <canvas id="treeCanvas" width="400" height="400"></canvas>
        </div>
    </div>

    <div class="controls-area">
        <div class="input-group">
            <div><label>X:</label> <input type="number" id="inX" placeholder="0-400"></div>
            <div><label>Y:</label> <input type="number" id="inY" placeholder="0-400"></div>
            <div style="border-left: 1px solid #ddd; padding-left: 10px; margin-left: 10px;">
                <label>Raio/Tam:</label> <input type="number" id="inSize" value="50" placeholder="50">
            </div>
        </div>

        <div class="btn-group">
            <button id="btn-auto" class="btn-auto" onclick="toggleAutoInsert()">‚ñ∂ Auto Inserir</button>
            <button class="btn-insert" onclick="actionInsert()">+ Inserir Manual</button>
            <button class="btn-exact" onclick="actionExactSearch()">üîç Busca Exata</button>
            <button class="btn-range" onclick="actionRangeSearch()">üì¶ Busca Intervalo</button>
            <button class="btn-nn" onclick="actionNearestNeighbor()">üéØ Vizinho + Pr√≥ximo</button>
            <button class="btn-del" onclick="actionDelete()">üóëÔ∏è Remover</button>
            <button class="btn-clear" onclick="resetAll()">‚ôªÔ∏è Limpar</button>
        </div>
    </div>

    <div id="log-container">
        <div class="log-header">
            <span>TERMINAL DE EXECU√á√ÉO (Processo Detalhado)</span>
            <span id="status-indicator" style="color:#aaa; font-size:0.9em;">Ocioso</span>
        </div>
        <ul id="log-content">
            <li class="log-line"><span class="log-time">Sys</span> <span class="log-info">Sistema iniciado.</span></li>
        </ul>
    </div>

    <script>
        // --- VARI√ÅVEIS E SETUP ---
        const spatialCv = document.getElementById('spatialCanvas');
        const spatialCtx = spatialCv.getContext('2d');
        const treeCv = document.getElementById('treeCanvas');
        const treeCtx = treeCv.getContext('2d');
        const logList = document.getElementById('log-content');
        
        let root = null;
        let autoInterval = null;

        // --- CLASSE NODE ---
        class Node {
            constructor(point, axis) {
                this.point = point; 
                this.left = null;
                this.right = null;
                this.axis = axis; // 0=X, 1=Y
            }
        }

        // --- ALGORITMOS KD-TREE (COM LOGGING) ---
        
        // Helper para indenta√ß√£o visual no log
        const getIndent = (depth) => " ".repeat(depth) + "‚Ü≥ ";

        function insert(node, point, depth, verbose = false) {
            if (!node) {
                if(verbose) log(`${getIndent(depth)}Criou folha no N√≠vel ${depth}`, 'step');
                return new Node(point, depth % 2);
            }
            
            // Duplicatas
            if (node.point[0] === point[0] && node.point[1] === point[1]) {
                if(verbose) log(`${getIndent(depth)}Ponto duplicado encontrado. Ignorando.`, 'step');
                return node; 
            }

            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            
            if (point[axis] < node.point[axis]) {
                if(verbose) log(`${getIndent(depth)}Comparando ${axisName}: ${point[axis]} < ${node.point[axis]} ‚Üí Esquerda`, 'step');
                node.left = insert(node.left, point, depth + 1, verbose);
            } else {
                if(verbose) log(`${getIndent(depth)}Comparando ${axisName}: ${point[axis]} ‚â• ${node.point[axis]} ‚Üí Direita`, 'step');
                node.right = insert(node.right, point, depth + 1, verbose);
            }
            return node;
        }

        function findExact(node, point, depth = 0) {
            if (!node) {
                log(`${getIndent(depth)}Chegou em Nulo. Ponto n√£o existe aqui.`, 'step');
                return null;
            }
            
            log(`${getIndent(depth)}Visitando (${node.point[0]}, ${node.point[1]})`, 'step');

            if (node.point[0] === point[0] && node.point[1] === point[1]) return node;
            
            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            
            if (point[axis] < node.point[axis]) {
                log(`${getIndent(depth)}Busca ${axisName}: ${point[axis]} < ${node.point[axis]} ‚Üí Esquerda`, 'step');
                return findExact(node.left, point, depth + 1);
            } else {
                log(`${getIndent(depth)}Busca ${axisName}: ${point[axis]} ‚â• ${node.point[axis]} ‚Üí Direita`, 'step');
                return findExact(node.right, point, depth + 1);
            }
        }

        function rangeSearch(node, range, results = [], depth = 0) {
            if (!node) return results;
            
            const x = node.point[0]; 
            const y = node.point[1];
            const axis = node.axis;

            // Verifica se o n√≥ est√° dentro
            const inside = (x >= range.minX && x <= range.maxX && y >= range.minY && y <= range.maxY);
            if (inside) {
                log(`${getIndent(depth)}Ponto (${x},${y}) est√° DENTRO da regi√£o! Adicionado.`, 'step');
                results.push(node);
            } else {
                // Opcional: Logar que visitou mas n√£o est√° dentro (pode gerar muito spam)
                // log(`${getIndent(depth)}Visitou (${x},${y}) - Fora`, 'step');
            }

            // L√≥gica de Poda
            if (axis === 0) { // Corte X
                // Se o inicio da regi√£o (minX) est√° √† esquerda do ponto, precisamos checar a esquerda
                if (range.minX <= x) {
                    rangeSearch(node.left, range, results, depth + 1);
                } else {
                    log(`${getIndent(depth)}Poda: Regi√£o inteira √† direita de X=${x}. Ignorando Esquerda.`, 'step');
                }
                
                if (range.maxX >= x) {
                    rangeSearch(node.right, range, results, depth + 1);
                } else {
                    log(`${getIndent(depth)}Poda: Regi√£o inteira √† esquerda de X=${x}. Ignorando Direita.`, 'step');
                }
            } else { // Corte Y
                if (range.minY <= y) {
                    rangeSearch(node.left, range, results, depth + 1);
                } else {
                    log(`${getIndent(depth)}Poda: Regi√£o inteira abaixo de Y=${y}. Ignorando Cima (Esq).`, 'step');
                }
                
                if (range.maxY >= y) {
                    rangeSearch(node.right, range, results, depth + 1);
                } else {
                    log(`${getIndent(depth)}Poda: Regi√£o inteira acima de Y=${y}. Ignorando Baixo (Dir).`, 'step');
                }
            }
            return results;
        }

        function nearestNeighbor(node, target, best, depth = 0) {
            if (!node) return best;

            const dist = distSq(node.point, target);
            const indent = getIndent(depth);

            // Atualiza melhor
            if (dist < best.dist) {
                best.node = node;
                best.dist = dist;
                log(`${indent}Novo Melhor Encontrado: (${node.point}) Dist: ${Math.sqrt(dist).toFixed(1)}`, 'step');
            }

            const axis = node.axis;
            const diff = target[axis] - node.point[axis];
            
            // Decide lado bom e ruim
            let goodSide = node.left;
            let badSide = node.right;
            let sideName = "Esquerda";
            
            if (diff > 0) { 
                goodSide = node.right; 
                badSide = node.left; 
                sideName = "Direita";
            }

            log(`${indent}Descendo para o lado prov√°vel (${sideName})`, 'step');
            
            // 1. Recurs√£o Lado Bom
            best = nearestNeighbor(goodSide, target, best, depth + 1);

            // 2. Verifica Poda (Backtracking)
            // Se a dist√¢ncia at√© o plano de corte for menor que a melhor dist√¢ncia atual, 
            // precisamos checar o outro lado.
            const distToPlane = diff * diff;
            
            if (distToPlane < best.dist) {
                log(`${indent}Backtracking: Raio cruza o plano de corte. Checando lado oposto...`, 'step');
                best = nearestNeighbor(badSide, target, best, depth + 1);
            } else {
                log(`${indent}Poda Geom√©trica: O outro lado est√° longe demais. Ignorando.`, 'step');
            }

            return best;
        }

        function distSq(p1, p2) { return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2; }

        function getAllPoints(node, list = []) {
            if (!node) return list;
            list.push(node.point);
            getAllPoints(node.left, list);
            getAllPoints(node.right, list);
            return list;
        }

        // --- VISUALIZA√á√ÉO (IGUAL AO ANTERIOR) ---
        function drawSpatial(highlightNodes = [], searchRect = null, nnData = null) {
            spatialCtx.clearRect(0, 0, spatialCv.width, spatialCv.height);
            if (root) drawSpatialNode(root, 0, spatialCv.width, 0, spatialCv.height, 0);

            if (searchRect) {
                spatialCtx.fillStyle = "rgba(142, 68, 173, 0.2)"; spatialCtx.strokeStyle = "#8e44ad"; spatialCtx.lineWidth = 2;
                const w = searchRect.maxX - searchRect.minX; const h = searchRect.maxY - searchRect.minY;
                spatialCtx.fillRect(searchRect.minX, searchRect.minY, w, h); spatialCtx.strokeRect(searchRect.minX, searchRect.minY, w, h);
            }
            highlightNodes.forEach(node => {
                spatialCtx.fillStyle = "#f1c40f"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 8, 0, Math.PI*2); spatialCtx.fill(); spatialCtx.strokeStyle = "black"; spatialCtx.stroke();
            });
            if (nnData) {
                spatialCtx.strokeStyle = "#e67e22"; spatialCtx.setLineDash([5, 5]);
                spatialCtx.beginPath(); spatialCtx.arc(nnData.target[0], nnData.target[1], Math.sqrt(nnData.dist), 0, Math.PI*2); spatialCtx.stroke(); spatialCtx.setLineDash([]);
                if (nnData.node) {
                    spatialCtx.beginPath(); spatialCtx.moveTo(nnData.target[0], nnData.target[1]); spatialCtx.lineTo(nnData.node.point[0], nnData.node.point[1]); spatialCtx.stroke();
                    spatialCtx.fillStyle = "#e67e22"; spatialCtx.beginPath(); spatialCtx.arc(nnData.node.point[0], nnData.node.point[1], 8, 0, Math.PI*2); spatialCtx.fill();
                }
            }
        }

        function drawSpatialNode(node, minX, maxX, minY, maxY, depth) {
            if (!node) return;
            spatialCtx.lineWidth = 1;
            if (node.axis === 0) { 
                spatialCtx.strokeStyle = "#ff6b6b";
                spatialCtx.beginPath(); spatialCtx.moveTo(node.point[0], minY); spatialCtx.lineTo(node.point[0], maxY); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, node.point[0], minY, maxY, depth + 1); drawSpatialNode(node.right, node.point[0], maxX, minY, maxY, depth + 1);
            } else { 
                spatialCtx.strokeStyle = "#4d96ff";
                spatialCtx.beginPath(); spatialCtx.moveTo(minX, node.point[1]); spatialCtx.lineTo(maxX, node.point[1]); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, maxX, minY, node.point[1], depth + 1); drawSpatialNode(node.right, minX, maxX, node.point[1], maxY, depth + 1);
            }
            spatialCtx.fillStyle = "#2d3436"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 4, 0, Math.PI*2); spatialCtx.fill();
            
            spatialCtx.fillStyle = "#636e72"; spatialCtx.font = "11px Arial";
            const label = `(${node.point[0]},${node.point[1]})`;
            let textX, textY;
            if (depth % 2 === 0) { spatialCtx.textAlign = "left"; spatialCtx.textBaseline = "bottom"; textX = node.point[0] + 6; textY = node.point[1] - 6; } 
            else { spatialCtx.textAlign = "right"; spatialCtx.textBaseline = "top"; textX = node.point[0] - 6; textY = node.point[1] + 6; }
            spatialCtx.fillText(label, textX, textY);
        }

        function drawHierarchy() {
            treeCtx.clearRect(0, 0, treeCv.width, treeCv.height);
            if (root) drawHierarchyNode(root, treeCv.width / 2, 30, treeCv.width / 4);
        }

        function drawHierarchyNode(node, x, y, offset) {
            if (!node) return;
            treeCtx.strokeStyle = "#b2bec3"; treeCtx.lineWidth = 2;
            if (node.left) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x - offset, y + 50); treeCtx.stroke(); drawHierarchyNode(node.left, x - offset, y + 50, offset / 2); }
            if (node.right) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x + offset, y + 50); treeCtx.stroke(); drawHierarchyNode(node.right, x + offset, y + 50, offset / 2); }
            treeCtx.fillStyle = node.axis === 0 ? "#fab1a0" : "#74b9ff"; treeCtx.strokeStyle = node.axis === 0 ? "#d63031" : "#0984e3"; treeCtx.lineWidth = 1;
            treeCtx.beginPath(); treeCtx.arc(x, y, 15, 0, Math.PI * 2); treeCtx.fill(); treeCtx.stroke();
            treeCtx.fillStyle = "#2d3436"; treeCtx.font = "bold 9px Arial"; treeCtx.textAlign = "center"; treeCtx.textBaseline = "middle"; treeCtx.fillText(`${node.point[0]},${node.point[1]}`, x, y);
        }

        // --- A√á√ïES E LOGS ---
        function log(msg, type = 'info') {
            // No modo autom√°tico, ignoramos logs do tipo 'step' para n√£o travar o browser
            if (autoInterval && type === 'step') return;

            const now = new Date(); 
            const timeStr = now.toLocaleTimeString('pt-BR', { hour12: false });
            const li = document.createElement('li'); 
            li.className = `log-line log-${type}`;
            
            // Se for passo a passo, n√£o mostra timestamp para ficar mais limpo
            if (type === 'step') {
                li.innerHTML = `${msg}`;
            } else {
                li.innerHTML = `<span class="log-time">${timeStr}</span> ${msg}`;
            }
            
            logList.appendChild(li); 
            logList.scrollTop = logList.scrollHeight;
        }
        
        function clearLog() {
            logList.innerHTML = '';
        }

        function getInputs() {
            const x = parseInt(document.getElementById('inX').value);
            const y = parseInt(document.getElementById('inY').value);
            const size = parseInt(document.getElementById('inSize').value) || 50;
            return { x, y, size };
        }
        function updateAll() { drawSpatial(); drawHierarchy(); }

        // --- A√á√ïES ---

        function toggleAutoInsert() {
            const btn = document.getElementById('btn-auto');
            const status = document.getElementById('status-indicator');
            
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                btn.innerHTML = "‚ñ∂ Auto Inserir";
                btn.style.background = "#16a085";
                status.innerText = "Ocioso";
                log("Auto inser√ß√£o pausada.", "info");
            } else {
                log("Iniciando inser√ß√£o autom√°tica (Logs detalhados ocultos)...", "info");
                btn.innerHTML = "‚è∏ Parar";
                btn.style.background = "#c0392b";
                status.innerText = "Rodando...";
                status.style.color = "#2ecc71";
                document.getElementById('inX').value = ''; document.getElementById('inY').value = '';
                actionInsert(); 
                autoInterval = setInterval(() => {
                    document.getElementById('inX').value = ''; document.getElementById('inY').value = '';
                    actionInsert();
                }, 300);
            }
        }

        function actionInsert() {
            let { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) {
                x = Math.floor(Math.random()*380)+10;
                y = Math.floor(Math.random()*380)+10;
                if (!autoInterval) {
                    document.getElementById('inX').value = x;
                    document.getElementById('inY').value = y;
                }
            }
            
            // Se for manual, limpamos o log para focar na nova a√ß√£o
            if(!autoInterval) {
                clearLog();
                log(`Iniciando inser√ß√£o de (${x}, ${y})...`, 'info');
            }

            // Passamos 'true' no √∫ltimo par√¢metro para ativar o verbose (log detalhado)
            // Mas a fun√ß√£o log() filtra isso se estiver no modo auto
            root = insert(root, [x, y], 0, true); 
            
            updateAll();
            log(`Sucesso: Ponto (${x}, ${y}) inserido.`, 'success');
        }

        function actionExactSearch() {
            if (autoInterval) toggleAutoInsert();
            clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");

            log(`Iniciando Busca Exata por (${x}, ${y})...`, 'info');
            const result = findExact(root, [x, y]);
            
            if (result) { log(`Encontrado: (${x}, ${y})`, 'success'); drawSpatial([result]); } 
            else { log(`Resultado: Ponto n√£o encontrado.`, 'error'); drawSpatial(); }
            drawHierarchy();
        }

        function actionRangeSearch() {
            if (autoInterval) toggleAutoInsert();
            clearLog();
            const { x, y, size } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");

            const half = size / 2;
            const range = { minX: x - half, maxX: x + half, minY: y - half, maxY: y + half };
            
            log(`Iniciando Busca por Intervalo...`, 'info');
            log(`Regi√£o: X[${range.minX} a ${range.maxX}], Y[${range.minY} a ${range.maxY}]`, 'info');
            
            const results = rangeSearch(root, range);
            
            if (results.length > 0) { log(`Finalizado: ${results.length} pontos encontrados.`, 'highlight'); drawSpatial(results, range); } 
            else { log(`Finalizado: Nenhum ponto encontrado.`, 'info'); drawSpatial([], range); }
            drawHierarchy();
        }

        function actionNearestNeighbor() {
            if (autoInterval) toggleAutoInsert();
            if (!root) return log("√Årvore vazia.", "error");
            clearLog();
            
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");

            log(`Iniciando Busca Vizinho Mais Pr√≥ximo de (${x}, ${y})...`, 'info');
            
            const target = [x, y];
            // best inicial = infinito
            const result = nearestNeighbor(root, target, { node: null, dist: Infinity });
            
            if (result.node) {
                const dist = Math.sqrt(result.dist).toFixed(2);
                log(`Resultado Final: Ponto (${result.node.point}) com dist ${dist}`, 'highlight');
                drawSpatial([], null, { target: target, node: result.node, dist: result.dist });
            }
            drawHierarchy();
        }

        function actionDelete() {
            if (autoInterval) toggleAutoInsert();
            clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Insira X e Y.", "error");

            let points = getAllPoints(root);
            const initLen = points.length;
            points = points.filter(p => p[0] !== x || p[1] !== y);

            if (points.length === initLen) { log(`Erro: Ponto n√£o encontrado para remo√ß√£o.`, 'error'); } 
            else {
                root = null; 
                log("Reconstruindo √°rvore sem o ponto removido...", 'info');
                points.forEach(p => root = insert(root, p, 0, false)); // False para n√£o logar reconstru√ß√£o
                updateAll(); 
                log(`Removido: (${x}, ${y})`, 'success');
            }
        }

        function resetAll() {
            if (autoInterval) toggleAutoInsert();
            root = null;
            updateAll();
            clearLog();
            log("√Årvore Resetada.", 'info');
            document.getElementById('inX').value = '';
            document.getElementById('inY').value = '';
        }

        spatialCv.addEventListener('mousedown', e => {
            const r = spatialCv.getBoundingClientRect();
            const x = Math.round(e.clientX - r.left);
            const y = Math.round(e.clientY - r.top);
            document.getElementById('inX').value = x;
            document.getElementById('inY').value = y;
        });

    </script>
</body>
</html>
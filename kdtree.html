<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Simulador K-D Tree (Passo a Passo Total)</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #eef1f5;
            margin: 0; padding: 20px;
            display: flex; flex-direction: column; height: 100vh;
            box-sizing: border-box; color: #333;
        }
        
        .back-btn {
            text-decoration: none; color: #555; font-weight: bold;
            display: flex; align-items: center; gap: 5px;
            font-size: 0.9rem; margin-bottom: 10px; width: fit-content;
        }
        .back-btn:hover { color: #000; text-decoration: underline; }

        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        h1 { margin: 0; font-size: 1.4rem; color: #2c3e50; }
        p.subtitle { margin: 0; color: #7f8c8d; font-size: 0.85rem; }

        /* --- LAYOUT DASHBOARD --- */
        .app-container {
            display: flex; flex: 1; gap: 20px; overflow: hidden;
        }

        /* ESQUERDA */
        .left-pane {
            flex: 2; display: flex; flex-direction: column; gap: 10px;
            overflow-y: auto; padding-right: 5px;
        }
        .canvas-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .panel {
            background: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05); text-align: center;
            flex: 1; min-width: 300px;
        }
        canvas { 
            border: 1px solid #eee; background: #fafafa; 
            cursor: crosshair; border-radius: 4px; width: 100%; max-width: 380px;
        }
        h3 { margin: 0 0 5px 0; color: #555; font-size: 0.8rem; text-transform: uppercase; font-weight: 600;}
        .controls-area {
            background: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; gap: 8px; align-items: center;
        }

        /* DIREITA: TERMINAL */
        .right-pane {
            flex: 1; display: flex; flex-direction: column; min-width: 320px;
        }
        #log-container {
            background: #1e1e1e; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; flex: 1;
            overflow: hidden; border: 1px solid #333;
        }
        .log-header {
            background: #252526; color: #ccc; padding: 8px 15px;
            font-size: 0.75rem; border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: bold; letter-spacing: 0.5px;
        }
        #log-content {
            flex: 1; overflow-y: auto; padding: 10px;
            list-style: none; margin: 0;
            font-family: 'Consolas', 'Fira Code', monospace; font-size: 0.8rem;
        }
        
        /* Linhas do Log */
        .log-line { margin-bottom: 4px; padding-left: 5px; line-height: 1.4; border-left: 2px solid transparent; }
        .log-time { color: #569cd6; margin-right: 8px; font-size: 0.7rem; opacity: 0.7; }
        .log-info { color: #d4d4d4; }
        .log-success { color: #4ec9b0; border-left-color: #4ec9b0; }
        .log-error { color: #f44747; border-left-color: #f44747; }
        .log-highlight { color: #dcdcaa; font-weight: bold; border-left-color: #dcdcaa; }
        
        .log-step { color: #808080; font-size: 0.8rem; padding-left: 15px; display: block; }
        .log-step::before { content: "‚Ü≥ "; margin-right: 5px; color: #555; }
        .log-step-main { color: #9cdcfe; font-weight: bold; margin-top: 8px; display: block; border-top: 1px solid #333; padding-top: 5px;}

        /* Inputs e Bot√µes */
        .input-group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;}
        input { padding: 6px; width: 50px; text-align: center; border: 1px solid #ddd; border-radius: 4px; outline: none; }
        input:focus { border-color: #007bff; }
        label { font-size: 0.8rem; font-weight: bold; color: #555; }
        
        .btn-group { display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
        button {
            padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px;
            color: white; font-weight: 600; font-size: 0.8rem; transition: 0.1s;
        }
        button:hover { filter: brightness(110%); transform: translateY(-1px); }
        
        .btn-auto   { background: #16a085; width: 100px; }
        .btn-insert { background: #27ae60; } 
        .btn-exact  { background: #2980b9; } 
        .btn-range  { background: #8e44ad; } 
        .btn-nn     { background: #e67e22; } 
        .btn-del    { background: #c0392b; } 
        .btn-clear  { background: #7f8c8d; } 

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    </style>
</head>
<body>

    <header>
        <div>
            <a href="menu.html" class="back-btn">‚¨Ö Voltar ao Menu</a>
            <h1>Simulador K-D Tree (2D)</h1>
            <p class="subtitle">Passo a passo detalhado em TODAS as opera√ß√µes.</p>
        </div>
    </header>

    <div class="app-container">
        
        <div class="left-pane">
            <div class="canvas-row">
                <div class="panel">
                    <h3>Espa√ßo</h3>
                    <canvas id="spatialCanvas" width="400" height="400"></canvas>
                </div>
                <div class="panel">
                    <h3>Hierarquia</h3>
                    <canvas id="treeCanvas" width="400" height="400"></canvas>
                </div>
            </div>

            <div class="controls-area">
                <div class="input-group">
                    <label>X:</label> <input type="number" id="inX" placeholder="X">
                    <label>Y:</label> <input type="number" id="inY" placeholder="Y">
                    <div style="width:1px; height:20px; background:#ddd; margin:0 5px;"></div>
                    <label>Raio:</label> <input type="number" id="inSize" value="50" placeholder="50">
                </div>

                <div class="btn-group">
                    <button id="btn-auto" class="btn-auto" onclick="toggleAutoInsert()">‚ñ∂ Auto</button>
                    <button class="btn-insert" onclick="actionInsert()">+ Inserir</button>
                    <button class="btn-exact" onclick="actionExactSearch()">üîç Busca Exata</button>
                    <button class="btn-range" onclick="actionRangeSearch()">üì¶ Intervalo</button>
                    <button class="btn-nn" onclick="actionNearestNeighbor()">üéØ Vizinho</button>
                    <button class="btn-del" onclick="actionDelete()">üóëÔ∏è Remover</button>
                    <button class="btn-clear" onclick="resetAll()">‚ôªÔ∏è Limpar</button>
                </div>
            </div>
        </div>

        <div class="right-pane">
            <div id="log-container">
                <div class="log-header">
                    <span>TERMINAL DE PASSOS</span>
                    <span id="status-indicator" style="color:#6a9955;">‚óè Online</span>
                </div>
                <ul id="log-content">
                    <li class="log-line"><span class="log-time">Sys</span> <span class="log-info">Pronto. Aguardando comando...</span></li>
                </ul>
            </div>
        </div>

    </div>

    <script>
        // --- VARI√ÅVEIS GLOBAIS ---
        const spatialCv = document.getElementById('spatialCanvas');
        const spatialCtx = spatialCv.getContext('2d');
        const treeCv = document.getElementById('treeCanvas');
        const treeCtx = treeCv.getContext('2d');
        const logList = document.getElementById('log-content');
        
        let root = null;
        let autoInterval = null;
        const getIndent = (d) => ""; 

        // --- CLASSE NODE ---
        class Node {
            constructor(point, axis) {
                this.point = point; 
                this.left = null; this.right = null;
                this.axis = axis; 
            }
        }

        // --- ALGORITMOS (CORE) ---

        function insert(node, point, depth, verbose = false) {
            if (!node) {
                if(verbose) log(`N√≠vel ${depth}: Criado n√≥ folha (${point}).`, 'step');
                return new Node(point, depth % 2);
            }
            
            if (node.point[0] === point[0] && node.point[1] === point[1]) {
                if(verbose) log(`N√≠vel ${depth}: Ponto j√° existe. Ignorando.`, 'step');
                return node; 
            }

            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            
            if (point[axis] < node.point[axis]) {
                if(verbose) log(`N√≠vel ${depth}: ${point[axis]} < ${node.point[axis]} (${axisName}) ‚Üí Esquerda`, 'step');
                node.left = insert(node.left, point, depth + 1, verbose);
            } else {
                if(verbose) log(`N√≠vel ${depth}: ${point[axis]} ‚â• ${node.point[axis]} (${axisName}) ‚Üí Direita`, 'step');
                node.right = insert(node.right, point, depth + 1, verbose);
            }
            return node;
        }

        function findExact(node, point, depth = 0) {
            if (!node) {
                log(`N√≠vel ${depth}: N√≥ nulo. Caminho sem sa√≠da.`, 'step');
                return null;
            }
            
            if (node.point[0] === point[0] && node.point[1] === point[1]) return node;

            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            const dir = point[axis] < node.point[axis] ? "Esquerda" : "Direita";
            
            log(`N√≠vel ${depth}: N√≥(${node.point}). Comp ${axisName}: ${point[axis]} vs ${node.point[axis]}. Indo ${dir}`, 'step');

            if (point[axis] < node.point[axis]) return findExact(node.left, point, depth + 1);
            else return findExact(node.right, point, depth + 1);
        }

        function rangeSearch(node, range, results = [], depth = 0) {
            if (!node) return results;
            
            const x = node.point[0]; const y = node.point[1];
            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';

            // Verifica se est√° dentro
            const inside = (x >= range.minX && x <= range.maxX && y >= range.minY && y <= range.maxY);
            if (inside) {
                log(`N√≠vel ${depth}: N√≥(${x},${y}) est√° DENTRO da regi√£o!`, 'step');
                results.push(node);
            }

            // L√≥gica de Poda (Pruning) Explicita
            if (axis === 0) { // Corte X
                if (range.minX <= x) {
                    rangeSearch(node.left, range, results, depth + 1);
                } else {
                    log(`N√≠vel ${depth}: PODA ESQUERDA (MinX ${range.minX} > N√≥X ${x})`, 'step');
                }
                if (range.maxX >= x) {
                    rangeSearch(node.right, range, results, depth + 1);
                } else {
                    log(`N√≠vel ${depth}: PODA DIREITA (MaxX ${range.maxX} < N√≥X ${x})`, 'step');
                }
            } else { // Corte Y
                if (range.minY <= y) {
                    rangeSearch(node.left, range, results, depth + 1);
                } else {
                    log(`N√≠vel ${depth}: PODA CIMA (MinY ${range.minY} > N√≥Y ${y})`, 'step');
                }
                if (range.maxY >= y) {
                    rangeSearch(node.right, range, results, depth + 1);
                } else {
                    log(`N√≠vel ${depth}: PODA BAIXO (MaxY ${range.maxY} < N√≥Y ${y})`, 'step');
                }
            }
            return results;
        }

        function nearestNeighbor(node, target, best, depth = 0) {
            if (!node) return best;

            const dist = distSq(node.point, target);
            const axis = node.axis;
            const axisName = axis === 0 ? 'X' : 'Y';
            
            if (dist < best.dist) {
                best.node = node;
                best.dist = dist;
                log(`N√≠vel ${depth}: Novo Vizinho Mais Pr√≥ximo! (${node.point}) Dist: ${Math.sqrt(dist).toFixed(1)}`, 'step');
            }

            const diff = target[axis] - node.point[axis];
            let goodSide = node.left, badSide = node.right;
            
            if (diff > 0) { 
                goodSide = node.right; badSide = node.left; 
            }

            // 1. Descer lado bom
            best = nearestNeighbor(goodSide, target, best, depth + 1);

            // 2. Verificar Poda
            const distToPlane = diff * diff;
            if (distToPlane < best.dist) {
                log(`N√≠vel ${depth}: BACKTRACKING. Raio cruza eixo ${axisName}. Checando lado oposto...`, 'step');
                best = nearestNeighbor(badSide, target, best, depth + 1);
            } else {
                log(`N√≠vel ${depth}: PODA GEOM√âTRICA. Lado oposto longe demais.`, 'step');
            }
            return best;
        }

        function distSq(p1, p2) { return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2; }
        
        function getAllPoints(node, list = []) {
            if (!node) return list;
            list.push(node.point);
            getAllPoints(node.left, list); getAllPoints(node.right, list);
            return list;
        }

        // --- VISUALIZA√á√ÉO ---
        function drawSpatial(highlightNodes = [], searchRect = null, nnData = null) {
            spatialCtx.clearRect(0, 0, spatialCv.width, spatialCv.height);
            if (root) drawSpatialNode(root, 0, spatialCv.width, 0, spatialCv.height, 0);

            if (searchRect) {
                spatialCtx.fillStyle = "rgba(142, 68, 173, 0.15)"; spatialCtx.strokeStyle = "#8e44ad"; spatialCtx.lineWidth = 2;
                const w = searchRect.maxX - searchRect.minX; const h = searchRect.maxY - searchRect.minY;
                spatialCtx.fillRect(searchRect.minX, searchRect.minY, w, h); spatialCtx.strokeRect(searchRect.minX, searchRect.minY, w, h);
            }
            highlightNodes.forEach(node => {
                spatialCtx.fillStyle = "#f1c40f"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 6, 0, Math.PI*2); spatialCtx.fill(); spatialCtx.stroke();
            });
            if (nnData && nnData.node) {
                spatialCtx.strokeStyle = "#e67e22"; spatialCtx.setLineDash([4, 4]);
                spatialCtx.beginPath(); spatialCtx.arc(nnData.target[0], nnData.target[1], Math.sqrt(nnData.dist), 0, Math.PI*2); spatialCtx.stroke(); spatialCtx.setLineDash([]);
                spatialCtx.beginPath(); spatialCtx.moveTo(nnData.target[0], nnData.target[1]); spatialCtx.lineTo(nnData.node.point[0], nnData.node.point[1]); spatialCtx.stroke();
                spatialCtx.fillStyle = "#e67e22"; spatialCtx.beginPath(); spatialCtx.arc(nnData.node.point[0], nnData.node.point[1], 6, 0, Math.PI*2); spatialCtx.fill();
            }
        }

        function drawSpatialNode(node, minX, maxX, minY, maxY, depth) {
            if (!node) return;
            spatialCtx.lineWidth = 1;
            if (node.axis === 0) { 
                spatialCtx.strokeStyle = "#ff6b6b";
                spatialCtx.beginPath(); spatialCtx.moveTo(node.point[0], minY); spatialCtx.lineTo(node.point[0], maxY); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, node.point[0], minY, maxY, depth + 1); drawSpatialNode(node.right, node.point[0], maxX, minY, maxY, depth + 1);
            } else { 
                spatialCtx.strokeStyle = "#4d96ff";
                spatialCtx.beginPath(); spatialCtx.moveTo(minX, node.point[1]); spatialCtx.lineTo(maxX, node.point[1]); spatialCtx.stroke();
                drawSpatialNode(node.left, minX, maxX, minY, node.point[1], depth + 1); drawSpatialNode(node.right, minX, maxX, node.point[1], maxY, depth + 1);
            }
            spatialCtx.fillStyle = "#333"; spatialCtx.beginPath(); spatialCtx.arc(node.point[0], node.point[1], 3, 0, Math.PI*2); spatialCtx.fill();
            spatialCtx.fillStyle = "#666"; spatialCtx.font = "10px Arial";
            let tx = node.point[0], ty = node.point[1];
            if (depth % 2 === 0) { spatialCtx.textAlign = "left"; spatialCtx.textBaseline = "bottom"; tx+=4; ty-=4; } 
            else { spatialCtx.textAlign = "right"; spatialCtx.textBaseline = "top"; tx-=4; ty+=4; }
            spatialCtx.fillText(`(${node.point})`, tx, ty);
        }

        function drawHierarchy() {
            treeCtx.clearRect(0, 0, treeCv.width, treeCv.height);
            if (root) drawHierarchyNode(root, treeCv.width / 2, 30, treeCv.width / 4);
        }

        // FUN√á√ÉO MODIFICADA: AUMENTO DO RAIO DAS BOLINHAS
        function drawHierarchyNode(node, x, y, offset) {
            if (!node) return;
            treeCtx.strokeStyle = "#ccc"; treeCtx.lineWidth = 1;
            if (node.left) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x - offset, y + 45); treeCtx.stroke(); drawHierarchyNode(node.left, x - offset, y + 45, offset / 2); }
            if (node.right) { treeCtx.beginPath(); treeCtx.moveTo(x, y); treeCtx.lineTo(x + offset, y + 45); treeCtx.stroke(); drawHierarchyNode(node.right, x + offset, y + 45, offset / 2); }
            treeCtx.fillStyle = node.axis === 0 ? "#ffecec" : "#ecf3ff"; treeCtx.strokeStyle = node.axis === 0 ? "#e74c3c" : "#3498db"; treeCtx.lineWidth = 1;
            
            // AQUI: Raio aumentado de 12 para 18
            treeCtx.beginPath(); treeCtx.arc(x, y, 18, 0, Math.PI * 2); treeCtx.fill(); treeCtx.stroke();
            
            // AQUI: Fonte aumentada de 9px para 11px
            treeCtx.fillStyle = "#333"; treeCtx.font = "bold 11px Arial"; treeCtx.textAlign = "center"; treeCtx.textBaseline = "middle"; treeCtx.fillText(`${node.point}`, x, y);
        }

        // --- LOG SYSTEM ---
        function log(msg, type = 'info') {
            if (autoInterval && type === 'step') return;
            const now = new Date(); 
            const timeStr = now.toLocaleTimeString('pt-BR', { hour12: false });
            const li = document.createElement('li'); 
            li.className = `log-line log-${type}`;
            
            if(type === 'step') li.className += ' log-step';
            if(type === 'step-main') li.className += ' log-step-main';

            if(type.startsWith('step')) li.innerHTML = `${msg}`;
            else li.innerHTML = `<span class="log-time">${timeStr}</span> ${msg}`;
            
            logList.appendChild(li); 
            requestAnimationFrame(() => { logList.scrollTop = logList.scrollHeight; });
        }
        
        function clearLog() { logList.innerHTML = ''; }
        function getInputs() {
            const x = parseInt(document.getElementById('inX').value);
            const y = parseInt(document.getElementById('inY').value);
            const size = parseInt(document.getElementById('inSize').value) || 50;
            return { x, y, size };
        }
        function updateAll() { drawSpatial(); drawHierarchy(); }

        // --- A√á√ïES (HANDLERS) ---

        function toggleAutoInsert() {
            const btn = document.getElementById('btn-auto');
            if (autoInterval) {
                clearInterval(autoInterval); autoInterval = null;
                btn.innerText = "‚ñ∂ Auto"; btn.style.background = "#16a085";
                log("Auto inser√ß√£o parada.", 'info');
            } else {
                log("Auto inser√ß√£o iniciada...", 'info');
                btn.innerText = "‚è∏ Parar"; btn.style.background = "#c0392b";
                const runAuto = () => { actionInsert(Math.floor(Math.random()*360)+20, Math.floor(Math.random()*360)+20); };
                runAuto();
                autoInterval = setInterval(runAuto, 400);
            }
        }

        function actionInsert(autoX, autoY) {
            let x, y;
            if (typeof autoX !== 'undefined') { x = autoX; y = autoY; } 
            else {
                const inp = getInputs(); x = inp.x; y = inp.y;
                if (isNaN(x) || isNaN(y)) { x = Math.floor(Math.random()*360)+20; y = Math.floor(Math.random()*360)+20; document.getElementById('inX').value = x; document.getElementById('inY').value = y; }
                clearLog(); log(`Inserindo Ponto (${x}, ${y})...`, 'step-main');
            }
            root = insert(root, [x, y], 0, !autoInterval);
            updateAll();
            if(!autoInterval) log(`Sucesso: (${x},${y}) adicionado.`, 'success');
        }

        function actionExactSearch() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Preencha X e Y.", 'error');
            log(`Iniciando Busca Exata por (${x}, ${y})...`, 'step-main');
            const res = findExact(root, [x,y]);
            if(res) { log(`Resultado: ENCONTRADO!`, 'success'); drawSpatial([res]); } 
            else { log(`Resultado: Ponto n√£o existe na √°rvore.`, 'error'); drawSpatial(); }
        }

        function actionDelete() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Preencha X e Y.", 'error');
            log(`Removendo Ponto (${x},${y})...`, 'step-main');
            
            log(`1. Varrendo √°rvore para encontrar o ponto...`, 'step');
            let pts = getAllPoints(root);
            const exists = pts.find(p => p[0] === x && p[1] === y);
            
            if (!exists) {
                log(`Falha: Ponto n√£o encontrado na estrutura.`, 'error');
                return;
            }
            log(`2. Ponto encontrado. Isolando sub-√°rvores...`, 'step');
            const remaining = pts.filter(p => p[0] !== x || p[1] !== y);
            
            log(`3. Reconstruindo √°rvore balanceada com ${remaining.length} pontos...`, 'step');
            root = null; 
            remaining.forEach(p => root = insert(root, p, 0, false)); 
            
            updateAll(); 
            log(`Opera√ß√£o conclu√≠da: Ponto removido.`, 'success');
        }

        function actionRangeSearch() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y, size } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Centro X, Y necess√°rio.", 'error');
            log(`Busca Intervalo (Raio ${size}) em (${x},${y})`, 'step-main');
            const half = size/2;
            const range = { minX:x-half, maxX:x+half, minY:y-half, maxY:y+half };
            const res = rangeSearch(root, range, [], 0);
            if(res.length) { log(`FIM: Encontrados ${res.length} pontos.`, 'highlight'); drawSpatial(res, range); }
            else { log(`FIM: Nenhum ponto na √°rea.`, 'info'); drawSpatial([], range); }
        }

        function actionNearestNeighbor() {
            if(autoInterval) toggleAutoInsert(); clearLog();
            const { x, y } = getInputs();
            if (isNaN(x) || isNaN(y)) return log("Erro: Alvo X, Y necess√°rio.", 'error');
            if (!root) return log("√Årvore vazia.", 'error');
            
            log(`Buscando Vizinho Mais Pr√≥ximo de (${x},${y})`, 'step-main');
            const res = nearestNeighbor(root, [x,y], {node:null, dist:Infinity}, 0);
            
            if(res.node) {
                const d = Math.sqrt(res.dist).toFixed(1);
                log(`RESULTADO: (${res.node.point}) | Dist: ${d}`, 'highlight');
                drawSpatial([], null, {target:[x,y], node:res.node, dist:res.dist});
            }
        }

        function resetAll() {
            if(autoInterval) toggleAutoInsert();
            root = null; updateAll(); clearLog(); log("Mem√≥ria limpa.", 'info');
        }

        spatialCv.addEventListener('mousedown', e => {
            const r = spatialCv.getBoundingClientRect();
            const x = Math.round(e.clientX - r.left);
            const y = Math.round(e.clientY - r.top);
            document.getElementById('inX').value = x;
            document.getElementById('inY').value = y;
            if(!autoInterval) log(`Selecionado: (${x}, ${y})`, 'info');
        });
    </script>
</body>
</html>